<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DigiDefender v2.0</title>
    <!-- Import Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        /* Modern Reset & Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* Prevent scroll bars */
            background-color: #0a0514; /* Deep dark blue/purple */
            font-family: 'Poppins', sans-serif; /* Clean default font */
            color: #e0e0e0; /* Light gray default text */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Game Container - Enhanced Scaling */
        #game-container {
            /* Removed fixed width/height */
            max-width: 1200px; /* Maximum size */
            max-height: 750px;
            height: 100vh; 
            aspect-ratio: 1200 / 750; /* Maintain aspect ratio */
            margin: auto; /* Center within the flex body */
            position: relative;
            border: 2px solid rgba(0, 188, 212, 0.3); /* Subtle cyan border */
            box-shadow: 0 0 40px rgba(0, 188, 212, 0.2), inset 0 0 15px rgba(10, 5, 20, 0.6); /* Cyan glow + dark inset */
            overflow: hidden;
            background: linear-gradient(180deg, rgba(1, 0, 2, 0.99) 0%, rgba(3, 1, 7, 0.99) 100%); /* Near-black gradient */
            border-radius: 12px; /* Slightly more rounded */
            transition: transform 0.1s ease; /* For screen shake */		
}
	
        /* Enhanced Starfield Background */
        @keyframes starfieldAnim {
            0% { background-position-y: 0px; }
            100% { background-position-y: -750px; } /* Match original max height */
        }

        .starfield {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(1px 1px at 20px 30px, #eee, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 80px 80px, #fff, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 90px 40px, #ddd, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 130px 150px, #eee, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 160px 120px, #ddd, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 180px 50px, #fff, rgba(0,0,0,0));
            background-repeat: repeat;
            background-size: 250px 250px; /* Slightly larger pattern */
            opacity: 0.5; /* More subtle */
            z-index: -5;
            animation: starfieldAnim 50s linear infinite; /* Slightly slower scroll */
        }
         /* Optional: Add a subtle nebula layer */
         #game-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(ellipse at 70% 30%, rgba(80, 30, 120, 0.15), transparent 70%),
                        radial-gradient(ellipse at 30% 80%, rgba(0, 100, 120, 0.1), transparent 60%);
            opacity: 0.8;
            z-index: -4;
            pointer-events: none;
         }


        /* Improved Spaceship - Subtle Changes */
        #spaceship {
            position: absolute;
            width: 60px;
            height: 80px;          
            transform: translate(0, 0); /* Use direct positioning via JS, no translate offset needed */
            z-index: 10;
            transition: transform 0.1s ease, filter 0.2s ease;
        }

        #spaceship .body {
            position: absolute;
            width: 30px;
            height: 50px;
            background: linear-gradient(to bottom, #e8e8e8, #b0b0b0); /* Slightly darker base */
            border-radius: 50% 50% 20% 20%;
            top: 10px;
            left: 15px;
            box-shadow: 0 0 15px rgba(200, 200, 255, 0.4); /* Soft white/blue glow */
            border: 1px solid #999;
        }

        #spaceship .wing {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 25px solid #777; /* Darker wings */
            filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.6));
            transition: transform 0.1s ease;
        }
        #spaceship .wing.left { left: 0; top: 25px; transform: rotate(-15deg); }
        #spaceship .wing.right { right: 0; top: 25px; transform: rotate(15deg); }

        /* Updated Propellant - Cyan Flame */
        #spaceship .propellant {
            position: absolute;
            width: 10px;
            height: 20px;
            background: linear-gradient(to bottom, #fff, #00bcd4, #00838f); /* White to cyan gradient */
            border-radius: 50%;
            bottom: -5px;
            left: 25px; /* Adjusted center */
            animation: flickerCyan 0.15s infinite alternate;
            box-shadow: 0 0 15px rgba(0, 220, 255, 0.8);
            transition: height 0.1s ease, bottom 0.1s ease, width 0.1s ease, background 0.1s ease, left 0.1s ease;
        }

        #spaceship .propellant.moving {
            height: 25px;
            bottom: -10px;
            background: linear-gradient(to bottom, #e0f7fa, #4dd0e1, #00acc1);
            animation-duration: 0.1s;
        }

        #spaceship .propellant.fast {
            height: 35px;
            bottom: -15px;
            width: 12px; /* Slightly wider */
            left: 24px; /* Center wider flame */
            background: linear-gradient(to bottom, #ffffff, #80deea, #26c6da);
            animation-duration: 0.07s;
        }

        @keyframes flickerCyan { /* Updated flicker for cyan */
            0% { opacity: 0.8; transform: scaleY(1.0); box-shadow: 0 0 12px rgba(0, 220, 255, 0.7); }
            50% { opacity: 1; transform: scaleY(1.1); box-shadow: 0 0 20px rgba(0, 255, 255, 1.0); }
            100% { opacity: 0.9; transform: scaleY(0.95); box-shadow: 0 0 15px rgba(0, 200, 230, 0.8); }
        }


        /* Enhanced Laser Effects - Cyan Theme */
        .laser {
            position: absolute;
            width: 6px; /* Slightly thicker */
            height: 28px; /* Slightly longer */
            background: linear-gradient(to bottom, #fff, #4dd0e1, #84ffff); /* White/Cyan */
            border-radius: 3px;
            box-shadow: 0 0 10px #00bcd4, 0 0 18px #4dd0e1, 0 0 4px #fff; /* Cyan/White glow */
            z-index: 5;
        }

        /* Hit flash effect - Cyan */
        .laser-hit-flash {
            position: absolute;
            width: 35px; /* Slightly larger */
            height: 35px;
            background: radial-gradient(circle, rgba(128, 222, 234, 0.9) 0%, rgba(0, 188, 212, 0) 70%); /* Cyan flash */
            border-radius: 50%;
            z-index: 6;
            pointer-events: none;
            animation: flashFadeCyan 0.2s ease-out forwards;
        }

        @keyframes flashFadeCyan {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(1.6); opacity: 0; }
        }


        /* Virus Styling - Subtle Glow Update */
        .virus {
            position: absolute;
            width: 48px;
            height: 48px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* Adjusted shadow colors - keeping some red/magenta hints for 'danger' */
            filter: drop-shadow(0 0 8px rgba(233, 30, 99, 0.6)); /* Magenta-ish glow */
            transition: transform 0.3s ease, filter 0.2s ease;
            animation: virusBob 2.5s infinite ease-in-out; /* Slightly slower bob */
        }

         @keyframes virusBob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); } /* Slightly more bob */
        }

        /* Specific Virus Shadows (Subtler) */
        .virus.d0 { background-image: url('Images/d0948.png'); width: 96px; height: 96px; filter: drop-shadow(0 0 15px rgba(0, 150, 136, 0.6)); } /* Teal hint */
        .virus.ateljee { background-image: url('Images/ateljee48.png'); filter: drop-shadow(0 0 12px rgba(255, 152, 0, 0.7)); } /* Keep orange hint */
        .virus.stadskantoor { background-image: url('Images/stadskantoor.png'); filter: drop-shadow(0 0 10px rgba(244, 67, 54, 0.7)); } /* Keep red hint */
        .virus.stadgent_minion {
             background-image: url('Images/stadgent128.png');
             width: 72px; /* Original size */
             height: 72px;
             background-size: contain;
            filter: drop-shadow(0 0 12px rgba(244, 67, 54, 0.8)); /* Reddish glow for minions */
        }

        /* Virus hit flash - Bright White */
        .virus.hit {
             filter: brightness(3.0) drop-shadow(0 0 20px #fff);
        }


        /* Virus Fragments */
        .virus-fragment {
            position: absolute;
            width: 32px;
            height: 32px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: drop-shadow(0 0 6px rgba(255, 100, 100, 0.4)); /* Fainter red glow */
            transition: all 0.4s ease-out;
            animation: spin 4s infinite linear; /* Slower spin */
            z-index: 4;
        }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* Specific fragment styles */
        .virus-fragment.d0 { background-image: url('Images/d0948.png'); width: 48px; height: 48px; }
        .virus-fragment.ateljee { background-image: url('Images/ateljee16.png'); width: 24px; height: 24px; }
        .virus-fragment.stadskantoor { background-image: url('Images/stadskantoor.png'); width: 32px; height: 32px; }

        .virus-fragment.fading {
             opacity: 0;
             transform: scale(0.4); /* Shrink more */
             transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }


        /* Modernized HUD */
        #hud {
            position: absolute;
            top: 15px; /* Slightly less space */
            left: 15px;
            color: #e0e0e0; /* Light gray text */
            z-index: 20;
            font-size: 12px; /* Slightly smaller base */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5); /* Subtle text shadow */
            background-color: rgba(26, 16, 50, 0.75); /* Dark translucent */
            padding: 10px 15px; /* Slightly less padding */
            border-radius: 8px;
            border: 1px solid rgba(0, 188, 212, 0.3); /* Subtle cyan border */
            backdrop-filter: blur(6px); /* Glassmorphism */
            min-width: 180px; /* Slightly narrower */
        }

        #score {
            margin-bottom: 6px; /* Less space */
            font-size: 16px; /* Slightly smaller */
            font-weight: bold; /* Keep bold */
            letter-spacing: 1px;
            color: #ffffff; /* White score */
            font-family: 'Orbitron', sans-serif; /* Keep Orbitron for score */
        }

        #hud #counters div { /* Target all counter divs */
            margin-bottom: 5px; /* Less space */
            display: flex;
            justify-content: space-between;
            font-size: 11px; /* Smaller details */
            color: #b0bec5; /* Lighter gray for details */
        }
        #hud #counters span:last-child { /* Value spans */
            font-weight: 600; /* Semi-bold */
            color: #ffffff;
            margin-left: 8px; /* Ensure space */
        }
         #hud hr {
             border-color: rgba(0, 188, 212, 0.2); margin: 4px 0;
         }
        #totaal-counter span:last-child,
        #subsidiestop-counter span:last-child {
            color: #ff8a65; /* Orange/Red warning color for limits */
        }

        /* Weapon Cooldown Bar - Modernized */
        #weapon-cooldown {
            width: 100%;
            height: 7px; /* Slightly thinner */
            background-color: rgba(0, 0, 10, 0.6); /* Darker base */
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px; /* Less space */
            border: 1px solid rgba(0, 188, 212, 0.2);
        }

        #weapon-charge {
            height: 100%;
            background: linear-gradient(to right, #00bcd4, #84ffff); /* Cyan gradient */
            border-radius: 4px;
            transition: width 0.05s linear;
            box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.4); /* Subtle inner shine */
        }

        /* Screens (Start, Settings, etc.) - Modern Overlay */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 15, 40, 0.9); /* Darker blue */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            color: #e0e0e0; /* Light text */
            text-align: center;
            backdrop-filter: blur(8px); /* Stronger blur for overlays */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0s linear 0.5s;
            padding: 20px; /* Add padding for smaller screens */
        }
         .screen.active {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease-in-out, visibility 0s linear 0s;
        }


        #start-screen h1 {
font-family: 'Orbitron', sans-serif; /* Keep Orbitron for title */
font-size: clamp(36px, 8vw, 64px); /* Responsive font size */
margin-bottom: 10px; /* Reduced gap */
color: #ffffff;
text-shadow: 0 0 25px rgba(0, 188, 212, 0.5), 0 0 30px rgba(0, 188, 212, 0.3); /* Cyan shadow */
letter-spacing: 3px;
font-weight: 700;
}
         #start-screen h4 { /* Subtitle */
             font-size: clamp(14px, 3vw, 20px); /* Responsive font size */
             margin-top: -5px;
             margin-bottom: 30px; /* More space before buttons */
             color: #80deea; /* Light cyan */
             font-weight: 300; /* Lighter weight */
             letter-spacing: 2px;
             text-shadow: 0 1px 2px rgba(0,0,0,0.5);
         }

        /* Modernized Glassmorphic Buttons */
        button {
            background: rgba(0, 188, 212, 0.1); /* Very transparent cyan */
            color: #e0e0e0; /* Light gray text */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle white border */
            padding: 12px 28px; /* Adjusted padding */
            margin: 12px; /* Adjusted margin */
            font-family: 'Poppins', sans-serif; /* Use Poppins */
            font-size: clamp(13px, 2.5vw, 16px); /* Responsive font size */
            font-weight: 400; /* Regular weight */
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); /* Softer shadow */
            min-width: 180px; /* Slightly narrower base */
            max-width: 90%; /* Prevent overflow on narrow screens */
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            backdrop-filter: blur(5px); /* Glass effect */
        }

        button:hover {
            background: rgba(0, 188, 212, 0.25); /* Slightly more visible cyan */
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 6px 20px rgba(0, 188, 212, 0.3); /* Cyan glow on hover */
            transform: translateY(-3px); /* Lift more */
            color: #ffffff; /* White text */
        }

        button:active {
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            background: rgba(0, 188, 212, 0.15);
        }

         /* Button Shine Effect (Subtler) */
         button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -150%;
            width: 30%; /* Narrower */
            height: 200%;
            background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0) 100%); /* Less intense shine */
            transform: skewX(-25deg);
            transition: left 0.7s ease; /* Slightly slower */
        }
        button:hover::after { left: 150%; }

        /* Settings & Rules Screens */
        #settings-screen h2, #rules-screen h2, #leaderboard-screen h2 {
            font-family: 'Orbitron', sans-serif; /* Orbitron for headings */
            font-size: clamp(28px, 6vw, 42px); /* Responsive */
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(0, 188, 212, 0.4);
            color: #ffffff;
            font-weight: 700;
        }

        .setting-group, .rules-content, .leaderboard-content {
            background: rgba(0, 188, 212, 0.1); /* Dark Blue-Gray */
             padding: 20px 25px; /* Adjusted padding */
             border-radius: 10px;
             border: 1px solid rgba(0, 188, 212, 0.2);
             margin-bottom: 15px; /* Less margin */
             width: 90%; /* Responsive width */
             max-width: 550px; /* Limit width */
             box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .setting-group h3 {
            font-size: clamp(16px, 3.5vw, 20px); /* Responsive */
            margin-bottom: 15px;
            text-align: center;
            color: #80deea; /* Light cyan */
            font-weight: 400;
        }

        .speed-selector {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap; /* Allow wrapping */
        }
        .speed-option {
            padding: 8px 15px; /* Smaller buttons */
            border: 1px solid rgba(0, 188, 212, 0.5);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(10, 5, 20, 0.5); /* Dark base */
            color: #b0bec5;
            font-size: clamp(12px, 2vw, 14px); /* Responsive */
        }
        .speed-option:hover {
            background: rgba(0, 188, 212, 0.2);
            color: #fff;
        }
        .speed-option.selected {
            background: #00bcd4; /* Solid cyan */
            color: #0a0514; /* Dark text */
            font-weight: 600;
            box-shadow: 0 0 15px rgba(0, 188, 212, 0.6);
            border-color: #84ffff;
        }

        .music-selector label {
             display: block;
             margin-bottom: 8px;
             font-size: clamp(16px, 3.5vw, 20px); /* Responsive */
             text-align: center;
             color: #80deea;
             font-weight: 400;
        }
        .music-selector select {
            background-color: rgba(10, 5, 20, 0.8); /* Dark bg */
            color: #e0e0e0;
            padding: 10px 15px; /* Adjusted */
            border: 1px solid rgba(0, 188, 212, 0.5);
            border-radius: 6px;
            font-family: 'Poppins', sans-serif;
            font-size: clamp(13px, 2.5vw, 16px); /* Responsive */
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.1);
            width: 100%;
            text-align: center;
            cursor: pointer;
            appearance: none; /* Basic style reset */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%2380deea' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E"); /* Simple dropdown arrow */
            background-repeat: no-repeat;
            background-position: right 15px center;
            padding-right: 40px; /* Space for arrow */
        }
         .music-selector select:focus { outline: 2px solid #4dd0e1; }


        /* Power-up Image Styling */
        #power-up-image {
             position: absolute;
             width: 48px; height: 48px;
             display: none;
            z-index: 8;
            /* Base animation and filter managed by type classes */
        }

        /* Base float animation */
        @keyframes float {
            from { transform: translateY(0) rotate(-5deg); }
            to { transform: translateY(-12px) rotate(5deg); }
        }

        /* Power-up Glows based on Type */
        #power-up-image.rapid { /* Cyan Glow */
            filter: drop-shadow(0 0 18px rgba(0, 229, 255, 0.9));
            animation: float 2s infinite alternate ease-in-out, powerUpGlowCyan 1.5s infinite;
        }
         @keyframes powerUpGlowCyan {
             0% { filter: drop-shadow(0 0 12px rgba(0, 229, 255, 0.7)); }
             50% { filter: drop-shadow(0 0 28px rgba(100, 239, 255, 1.0)); }
             100% { filter: drop-shadow(0 0 12px rgba(0, 229, 255, 0.7)); }
         }

        #power-up-image.double { /* Magenta Glow */
            filter: drop-shadow(0 0 18px rgba(233, 30, 99, 0.9));
            animation: float 2s infinite alternate ease-in-out, powerUpGlowMagenta 1.5s infinite;
        }
         @keyframes powerUpGlowMagenta {
             0% { filter: drop-shadow(0 0 12px rgba(233, 30, 99, 0.7)); }
             50% { filter: drop-shadow(0 0 28px rgba(255, 80, 150, 1.0)); }
             100% { filter: drop-shadow(0 0 12px rgba(233, 30, 99, 0.7)); }
         }

        #power-up-image.bomb { /* Yellow/White Glow */
            filter: drop-shadow(0 0 18px rgba(255, 255, 180, 0.9));
            animation: float 2s infinite alternate ease-in-out, powerUpGlowYellow 1.5s infinite;
        }
         @keyframes powerUpGlowYellow {
             0% { filter: drop-shadow(0 0 12px rgba(255, 255, 180, 0.7)); }
             50% { filter: drop-shadow(0 0 28px rgba(255, 255, 255, 1.0)); }
             100% { filter: drop-shadow(0 0 12px rgba(255, 255, 180, 0.7)); }
         }

        /* Powerup collected effect - Expanding Ring */
        .powerup-collect-effect {
            position: absolute;
            width: 50px; height: 50px;
            border: 4px solid #84ffff; /* Light cyan ring */
            border-radius: 50%;
            z-index: 25;
            pointer-events: none;
            animation: collectZoomCyan 0.5s ease-out forwards;
        }
        @keyframes collectZoomCyan {
             from { transform: scale(1); opacity: 0.9; }
             to { transform: scale(4.5); opacity: 0; }
         }

        /* Laser Bomb Style - Pulsing Cyan Orb */
        .laser-bomb {
            position: absolute;
            width: 24px; /* Larger */
            height: 24px;
            background: radial-gradient(circle, #e0f7fa 20%, #00bcd4 70%, #00838f 100%); /* Cyan orb gradient */
            border-radius: 50%;
            box-shadow: 0 0 18px #4dd0e1, 0 0 30px #84ffff, 0 0 8px #fff; /* Intense cyan/white glow */
            z-index: 5;
            animation: bombPulseCyan 0.4s infinite alternate;
        }
        @keyframes bombPulseCyan {
            from { transform: scale(1); box-shadow: 0 0 18px #4dd0e1, 0 0 30px #84ffff, 0 0 8px #fff; }
            to { transform: scale(1.1); box-shadow: 0 0 25px #4dd0e1, 0 0 40px #84ffff, 0 0 12px #fff; }
        }

        /* Bomb Explosion Effect - Bright Cyan/White */
        .bomb-explosion-flash {
            position: absolute;
            width: 70px; /* Larger flash */
            height: 70px;
            background: radial-gradient(circle, rgba(224, 247, 250, 1) 0%, rgba(77, 208, 225, 0.6) 50%, rgba(0, 188, 212, 0) 75%); /* Cyan/White explosion */
            border-radius: 50%;
            z-index: 6;
            pointer-events: none;
            animation: flashFadeLargeCyan 0.3s ease-out forwards;
        }
        @keyframes flashFadeLargeCyan {
            from { transform: scale(0.8); opacity: 1; }
            to { transform: scale(2.2); opacity: 0; }
        }


        /* Boss Styles - Red/Danger Theme */
        #boss-image {
             position: absolute;
             width: 128px; height: 128px;
             display: none;
            filter: drop-shadow(0 0 30px rgba(244, 67, 54, 0.9)) drop-shadow(0 0 10px rgba(255, 82, 82, 0.7)); /* Strong red glow */
            animation: bossFloat 3.5s infinite alternate ease-in-out; /* Slower float */
            transition: transform 0.3s ease, filter 0.2s ease;
            z-index: 9;
        }
         #boss-image.hit {
             filter: brightness(2.8) drop-shadow(0 0 40px #fff) drop-shadow(0 0 15px #ff5252); /* Brighter white/red hit */
             transform: scale(1.03); /* Bulge more */
         }

        .boss-health-container {
            position: absolute;
            width: 128px;
            padding: 3px;
            background-color: rgba(0, 0, 0, 0.85); /* Darker bg */
            border: 1px solid #f44336; /* Red border */
            border-radius: 5px;
            z-index: 9;
            box-shadow: 0 0 12px rgba(255, 82, 82, 0.7); /* Red glow */
            overflow: hidden;
        }
        .boss-health-bar {
            height: 10px; /* Thicker */
            background: linear-gradient(to right, #d32f2f, #ff5722, #ffab40); /* Red to orange gradient */
            border-radius: 3px;
            transition: width 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }
         /* Health Bar Shine (Subtle) */
         .boss-health-bar::after {
             content: ''; position: absolute; top: 0; left: 0;
             width: 100%; height: 100%;
             background: linear-gradient(90deg, transparent 20%, rgba(255, 255, 255, 0.15) 50%, transparent 80%);
             animation: healthBarShine 1.8s infinite linear;
         }
         @keyframes healthBarShine { from { transform: translateX(-100%); } to { transform: translateX(100%); } }

        @keyframes bossFloat { /* Slower, smoother boss movement */
            from { transform: translateY(0) rotate(-1.5deg) scale(1); }
            to { transform: translateY(-18px) rotate(1.5deg) scale(1.03); }
        }

        /* Sound Control - Modern Icon Button */
        #sound-toggle {
            position: absolute;
            top: 15px; /* Match HUD top */
            right: 15px; /* Match HUD left */
            width: 36px; height: 36px; /* Slightly smaller */
            background-size: 20px 20px; /* Control icon size */
            background-position: center;
            background-repeat: no-repeat;
            cursor: pointer;
            z-index: 25;
            transition: all 0.2s ease;
            border-radius: 50%;
            background-color: rgba(26, 16, 50, 0.6); /* Match HUD bg */
            border: 1px solid rgba(0, 188, 212, 0.3);
            filter: none; /* Remove old filter */
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #sound-toggle:hover {
            transform: scale(1.1);
            background-color: rgba(0, 188, 212, 0.2);
            box-shadow: 0 4px 10px rgba(0, 188, 212, 0.2);
        }
        /* SVG Icons Embedded */
        #sound-toggle.on {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%23e0e0e0' viewBox='0 0 16 16'%3E%3Cpath d='M11.536 14.01A8.47 8.47 0 0 0 14.026 8a8.47 8.47 0 0 0-2.49-6.01l-.708.707A7.48 7.48 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303z'/%3E%3Cpath d='M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.48 5.48 0 0 1 11.025 8a5.48 5.48 0 0 1-1.61 3.89z'/%3E%3Cpath d='M8.707 11.182A4.5 4.5 0 0 0 10.025 8a4.5 4.5 0 0 0-1.318-3.182L8 5.525A3.5 3.5 0 0 1 9.025 8 3.5 3.5 0 0 1 8 10.475zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z'/%3E%3C/svg%3E");
        }
        #sound-toggle.off {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%239e9e9e' viewBox='0 0 16 16'%3E%3Cpath d='M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zm7.137 2.096a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0z'/%3E%3C/svg%3E");
        }

        /* Game Over Screen */
        #game-over-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(38px, 9vw, 58px); /* Responsive */
            margin-bottom: 8px;
            color: #f44336; /* Red */
            text-shadow: 0 0 15px #ff5252, 0 0 25px #ff1744;
            font-weight: 700;
        }
         #game-over-screen h2 { /* Subtitle */
             font-size: clamp(18px, 4vw, 26px); /* Responsive */
             margin-bottom: 25px;
             color: #ff8a65; /* Lighter red/orange */
             font-weight: 300;
         }
        #final-score-label {
             font-size: clamp(16px, 3.5vw, 20px); /* Responsive */
             color: #bdbdbd; /* Medium gray */
             margin-bottom: 5px;
             font-weight: 300;
         }
        #final-score {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(50px, 12vw, 72px); /* Responsive */
            color: #4dd0e1; /* Bright Cyan */
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(77, 208, 225, 0.8), 0 0 35px rgba(0, 188, 212, 0.5);
            font-weight: 700;
        }

        /* Rules Screen Specifics */
        #rules-screen { padding: 20px; overflow-y: auto; } /* Allow scroll if needed */
        #rules-screen .rules-content {
             max-width: 700px; /* Wider rules */
             text-align: left;
             font-size: clamp(13px, 2.2vw, 15px); /* Responsive */
             line-height: 1.6;
             max-height: 65vh; /* Limit height and allow scroll */
             overflow-y: auto;
             padding-right: 10px; /* Space for scrollbar */
        }
        #rules-screen p { margin: 12px 0; }
        #rules-screen p strong {
            color: #84ffff; /* Lightest cyan for highlights */
            font-weight: 600;
        }
        /* Inline image styling for rules */
         #rules-screen img {
             width: 20px; height: 20px; /* Slightly smaller */
             vertical-align: -4px; /* Align better with text */
             margin: 0 3px;
             background: rgba(255,255,255,0.1); /* Slight bg for visibility */
             border-radius: 3px;
             padding: 1px;
         }
         /* Powerup color highlights in rules */
         #rules-screen .powerup-cyan { color: #4dd0e1; font-weight: 600; }
         #rules-screen .powerup-magenta { color: #f06292; font-weight: 600; } /* Magenta for double shot */
         #rules-screen .powerup-yellow { color: #fff176; font-weight: 600; } /* Yellow for bomb */


        /* Leaderboard Screen Specifics */
        #leaderboard-screen .leaderboard-content {
             width: 90%; /* Responsive */
             max-width: 500px;
             max-height: 65vh; /* Limit height */
             overflow-y: auto;
             padding: 15px 15px; /* Less padding inside table area */
        }
         /* Custom Scrollbar */
        #leaderboard-screen .leaderboard-content::-webkit-scrollbar { width: 8px; }
        #leaderboard-screen .leaderboard-content::-webkit-scrollbar-track { background: rgba(10, 5, 20, 0.5); border-radius: 4px;}
        #leaderboard-screen .leaderboard-content::-webkit-scrollbar-thumb { background: rgba(0, 188, 212, 0.4); border-radius: 4px;}
        #leaderboard-screen .leaderboard-content::-webkit-scrollbar-thumb:hover { background: rgba(0, 188, 212, 0.7); }

        #leaderboard-screen table {
            width: 100%;
            border-collapse: separate; /* Use separate for spacing */
            border-spacing: 0 4px; /* Vertical spacing between rows */
            font-size: clamp(13px, 2.2vw, 15px); /* Responsive */
        }
        #leaderboard-screen th {
            text-align: left;
            padding: 10px 8px; /* Adjusted */
            border-bottom: 2px solid rgba(0, 188, 212, 0.5);
            color: #80deea; /* Light cyan header */
            font-size: clamp(14px, 2.5vw, 16px); /* Responsive */
            font-weight: 600;
        }
        #leaderboard-screen td {
            padding: 8px; /* Adjusted */
            background: rgba(255, 255, 255, 0.03); /* Very subtle row background */
            border-bottom: 1px solid rgba(0, 188, 212, 0.1);
        }
        #leaderboard-screen tr:last-child td { border-bottom: none; } /* No border on last row */
        #leaderboard-screen td:first-child { border-radius: 5px 0 0 5px; } /* Rounded corners */
        #leaderboard-screen td:last-child { border-radius: 0 5px 5px 0; }

        #leaderboard-screen td:nth-child(1) { width: 15%; text-align: center; color: #b0bec5;} /* Rank */
        #leaderboard-screen td:nth-child(2) { width: 45%; font-weight: 600; color: #ffffff; } /* Score */
        #leaderboard-screen td:nth-child(3) { width: 40%; text-align: right; color: #90a4ae; font-size: clamp(11px, 2vw, 13px); /* Responsive */} /* Date */
        #leaderboard-screen .no-scores { text-align: center; padding: 25px; color: #90a4ae; font-size: clamp(14px, 2.5vw, 16px); }


        /* Pause Screen Styling */
        #pause-screen {
            /* Inherits .screen styles (background, blur, flex) */
            z-index: 50;
        }
        #pause-screen h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(32px, 7vw, 48px); /* Responsive */
            margin-bottom: 15px;
            color: #ffffff;
            text-shadow: 0 0 12px rgba(0, 188, 212, 0.5);
        }
        #pause-screen p { margin-bottom: 30px; color: #b0bec5; font-size: clamp(14px, 2.5vw, 16px); /* Responsive */ }
        #pause-screen button { margin: 10px; }

        /* Exit button styling (in pause menu) */
        #exit-to-menu-btn {
             background: rgba(244, 67, 54, 0.1); /* Reddish transparent */
             border-color: rgba(255, 138, 128, 0.3); /* Reddish border */
             color: #ff8a65; /* Lighter red text */
        }
        #exit-to-menu-btn:hover {
             background: rgba(244, 67, 54, 0.3);
             border-color: rgba(255, 138, 128, 0.6);
             box-shadow: 0 6px 20px rgba(244, 67, 54, 0.3);
             color: #ffffff;
        }


        /* Explosion Effects - Cyan/White/Purple hints */
        .explosion-particle {
            position: absolute;
            width: 6px; height: 6px;
            border-radius: 50%;
            /* Gradient: Center white -> cyan -> faint purple -> transparent */
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(128,222,234,0.9) 50%, rgba(171, 71, 188, 0.5) 80%, rgba(171, 71, 188, 0) 100%);
            box-shadow: 0 0 12px rgba(128, 222, 234, 0.7), 0 0 5px rgba(255, 255, 255, 0.5); /* Cyan/white glow */
            z-index: 7;
            pointer-events: none;
            /* Animation applied via JS */
        }

        /* --- MOBILE CONTROLS REMOVED --- */

        /* Loading Screen - Modernized */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0514; /* Match base background */
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100;
            color: #e0e0e0;
            opacity: 1;
            transition: opacity 0.5s ease-out 0.5s;
        }
         #loading-screen h2 {
             margin-bottom: 25px;
             font-size: clamp(20px, 5vw, 28px); /* Responsive */
             font-weight: 400;
             color: #80deea; /* Light cyan */
             letter-spacing: 1px;
             font-family: 'Orbitron', sans-serif;
             text-align: center;
         }
        .loading-bar-container {
            width: 80%; /* Responsive */
            max-width: 350px;
            height: 18px;
            background: rgba(26, 16, 50, 0.7); /* Dark translucent */
            border: 1px solid rgba(0, 188, 212, 0.3);
            border-radius: 9px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
        }
        #loading-bar {
            width: 0%; height: 100%;
            background: linear-gradient(to right, #00bcd4, #84ffff); /* Cyan gradient */
            transition: width 1.5s ease-out;
            border-radius: 9px;
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.5); /* Bar glow */
        }
         #loading-screen.hidden {
             opacity: 0;
             pointer-events: none;
         }

    </style>
</head>
<body>
    <div id="game-container">
        <div class="starfield"></div>

        <!-- HUD Display -->
        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="counters">
                <div id="afsprakennotas-counter"><span>Afsprakennotas:</span><span>0</span></div>
                <div id="inmengingen-counter"><span>Inmengingen:</span><span>0</span></div>
                <div id="meldingen-counter"><span>Meldingen:</span><span>0</span></div>
                <hr>
                <div id="totaal-counter"><span>Totaal Klachten:</span><span>0/10</span></div>
                <div id="subsidiestop-counter"><span>Subsidiestop:</span><span>0%</span></div>
            </div>
            <div id="weapon-cooldown">
                <div id="weapon-charge" style="width: 100%;"></div>
            </div>
        </div>

        <!-- Sound Toggle Button -->
        <div id="sound-toggle" class="on"></div> <!-- Start with 'on' class for initial icon -->

        <!-- Player Spaceship -->
        <div id="spaceship">
            <div class="body"></div>
            <div class="wing left"></div>
            <div class="wing right"></div>
            <div class="propellant"></div>
        </div>

        <!-- Power-Up Image -->
        <img id="power-up-image" src="Images/digi48.png"> <!-- Specific powerup class added by JS -->

        <!-- Screens -->
        <div id="start-screen" class="screen active"> <!-- Start active -->
            <h1>DigiDefender</h1>
            <h4>by FNX</h4>
            <br>
            <button id="start-game">Start Game</button>
            <button id="settings">Instellingen</button>
            <button id="rules">Spelregels</button>
            <button id="leaderboard">Leaderboard</button>
        </div>

        <div id="settings-screen" class="screen">
            <h2>Instellingen</h2>
            <div class="setting-group">
                <h3>Rakket Snelheid</h3>
                <div class="speed-selector">
                    <div class="speed-option" data-speed="slow">Traag</div>
                    <div class="speed-option selected" data-speed="normal">Normaal</div>
                    <div class="speed-option" data-speed="fast">Snel</div>
                </div>
            </div>
            <div class="setting-group music-selector">
                 <label for="background-music">Achtergrondmuziek</label>
                <select id="background-music">
                    <option value="Audio/8bitarcade.mp3" selected>FNX - DigiDefender Theme (80s Arcade)</option>
                    <option value="Audio/hardcore.mp3">The Destroyer - Arcade X-Perience (Speedcore 1996)</option>
                    <option value="Audio/talkinboutloveanthem.mp3">Van Halen - Ain't Talkin' Bout Love (FNX 80s Anthem Flip)</option>
                    <option value="Audio/ontheroad.mp3">Abel - Onderweg (FNX Nillies Punk Flip)</option>   
                    <option value="Audio/elysium.mp3">FNX - Elysium (House)</option>
                    <option value="Audio/kbounce.mp3">FNX - Hongdae Bounce (K-Pop / Future Bounce)</option>
                    <option value="Audio/vielleichtvielleicht.mp3">MilleniumKid & JBS - Vielleicht Vielleicht (FNX Metal Flip)</option>
                    <option value="all">Alles afspelen</option>
                </select>
            </div>
            <div>
                <button id="save-settings">Opslaan</button>
                <button id="back-to-menu">Terug</button>
            </div>
        </div>

        <div id="rules-screen" class="screen">
            <h2>Spelregels</h2>
            <div class="rules-content">
                <p>Verdedig het <strong>Digipunt</strong> tegen alle aanvallen!</p>
                <p>Gebruik <strong>Pijltjestoetsen</strong> of <strong>ZQSD / WASD</strong> om te bewegen.</p>
                <p>Gebruik <strong>ESC</strong> of <strong>P</strong> om het spel te pauzeren.</p>
                <p>Gebruik <strong>Spatiebalk</strong> om te schieten.</p>
                <p>Pak een <strong>Digipunt Power-up</strong> ( <img src="Images/digi48.png"> ).<br>              
                <p>Raak <strong>Afspraken</strong> ( <img src="Images/d0948.png"> ) om ze te vernietigen. Elke vernietigde <strong>Afspraak</strong> ontploft in verschillende <strong>Controleurs</strong> die zich verspreiden.</p>
                <p>Elke <strong>Afspraak</strong> die je rakket raakt of de bodem bereikt, geeft: <strong>1 klacht</strong>. <br> Elke <strong>Controleur</strong> die je rakket raakt geeft een waarschuwing: <strong>0.5 klacht</strong>.</p>
                <p>Bij <strong>10 totale klachten</strong> wordt je Digipunt gesloten (Game Over).</p>
                <p>Let op de <strong>Stad Gent</strong> baas ( <img src="Images/stadgent128.png"> )! De baas stuurt <strong>Inspecteurs</strong> ( <img src="Images/stadgent128.png"> ) die elk 12.5% van de subsidies terugtrekken bij impact. Zodra de <strong>Subsidiestop</strong> 100% bereikt, wordt iedereen ontslagen (Game Over)!</p>
            </div>
            <button id="back-to-menu-from-rules">Terug naar Menu</button>
        </div>

        <div id="game-over-screen" class="screen">
            <h1>Game Over!</h1>
            <h2>Je Digipunt wordt gesloten!</h2>
            <p id="final-score-label">Jouw Score:</p>
            <div id="final-score">0</div>
            <button id="restart-game">Opnieuw Spelen</button>
            <button id="view-high-scores">Bekijk Leaderboard</button>
            <button id="exit-to-menu-from-go">Terug Naar Menu</button>
        </div>

         <div id="leaderboard-screen" class="screen">
             <h2>High Scores</h2>
             <div class="leaderboard-content">
                 <!-- Table generated by JS -->
             </div>
             <button id="back-from-leaderboard">Terug naar Menu</button>
         </div>

         <!-- MOBILE CONTROLS REMOVED -->

        <!-- Loading screen -->
        <div id="loading-screen">
             <h2>Loading DigiDefender...</h2>
             <div class="loading-bar-container">
                <div id="loading-bar"></div>
            </div>
        </div>

   </div><!-- closing game-container-->

    <!-- Game Sound Effects -->
    <audio id="laser-sound" src="Audio/laser.mp3" preload="auto"></audio>
    <audio id="explosion-sound" src="Audio/explosion.mp3" preload="auto"></audio>
    <audio id="alarm-sound" src="Audio/alarm.mp3" preload="auto"></audio>
    <audio id="bigexplosion-sound" src="Audio/bigexplosion.mp3" preload="auto"></audio>
    <audio id="loser-sound" src="Audio/loser.mp3" preload="auto"></audio>
    <audio id="powerup-sound" src="Audio/powerup.mp3" preload="auto"></audio>
    <audio id="hit-sound" src="Audio/hit.mp3" preload="auto"></audio>
    <audio id="double-laser-sound" src="Audio/doublelaser.mp3" preload="auto"></audio> 
    <audio id="laser-bomb-sound" src="Audio/bomba.mp3"></audio> 
    

    <!-- Background Music Player -->
    <audio id="background-music-player" loop></audio>

<script>
    // --- DOM Elements ---
    const gameContainer = document.getElementById('game-container');
    const spaceship = document.getElementById('spaceship');
    const propellant = spaceship.querySelector('.propellant');
    const hudScore = document.getElementById('score');
    const afsprakennotasElement = document.getElementById('afsprakennotas-counter').querySelector('span:last-child');
    const inmengingenElement = document.getElementById('inmengingen-counter').querySelector('span:last-child');
    const meldingenElement = document.getElementById('meldingen-counter').querySelector('span:last-child');
    const totalCounterElement = document.getElementById('totaal-counter').querySelector('span:last-child');
    const subsidiestopElement = document.getElementById('subsidiestop-counter').querySelector('span:last-child');
    const weaponCooldownBar = document.getElementById('weapon-cooldown');
    const weaponChargeBar = document.getElementById('weapon-charge');
    const soundToggle = document.getElementById('sound-toggle');
    const powerUpImage = document.getElementById('power-up-image');
    const backgroundMusicPlayer = document.getElementById('background-music-player');
    const backgroundMusicSelect = document.getElementById('background-music');
    const loadingScreen = document.getElementById('loading-screen');
    const loadingBar = document.getElementById('loading-bar');

    // Screens
    const screens = {
        start: document.getElementById('start-screen'),
        settings: document.getElementById('settings-screen'),
        rules: document.getElementById('rules-screen'),
        gameOver: document.getElementById('game-over-screen'),
        leaderboard: document.getElementById('leaderboard-screen'),
    };
    const finalScoreElement = document.getElementById('final-score');

    // --- Game Constants ---
    // GAME_WIDTH and GAME_HEIGHT define the *logical* coordinate system inside the container
    const GAME_WIDTH = 1200;
    const GAME_HEIGHT = 750;
    const SHIP_WIDTH = 60;
    const SHIP_HEIGHT = 80;
    const LASER_WIDTH = 6; // Matched CSS
    const LASER_HEIGHT = 28; // Matched CSS
    const LASER_SPEED = 12;
    const BASE_WEAPON_COOLDOWN = 180; // Milliseconds
    const POWERUP_WEAPON_COOLDOWN = 60; // For rapid fire
    const POWERUP_DURATION = 8000; // 8 seconds
    const POWERUP_SPAWN_INTERVAL = 5000; // 25 seconds (can adjust)
    const BOSS_SPAWN_SCORE_THRESHOLD = 0; // Score needed for boss
    const BOSS_SPAWN_CHECK_INTERVAL = 120000; // Check every 2 mins
    const BOSS_SPAWN_CHANCE = 1.00; // 100% chance per check
    const MAX_DEDUCTIONS = 10;
    const MUSIC_PREVIEW_DURATION = 20000; // 20 seconds
    const LASER_BOMB_SPEED = 7; // Slightly slower bomb
    const LASER_BOMB_WIDTH = 34; // Matched CSS
    const LASER_BOMB_HEIGHT = 24; // Matched CSS
    const LASER_BOMB_DAMAGE_MULTIPLIER = 3;
    const DOUBLE_SHOT_SPACING = 25;
    const POWERUP_TYPES = ['rapid', 'double', 'bomb']; // Keep this for class names/logic

    // Movement Config (Your preference)
    const MOVEMENT_CONFIG = {
        slow: { baseSpeed: 10, acceleration: 0.7, maxSpeed: 9, friction: 0.88 },
        normal: { baseSpeed: 13, acceleration: 0.8, maxSpeed: 13, friction: 0.9 },
        fast: { baseSpeed: 18, acceleration: 1.0, maxSpeed: 20, friction: 0.92 }
    };

    // Virus Config (Using your images/logic)
    const VIRUS_CONFIG = {
        d0: { health: 3, baseSpeed: 1.8, points: 300, width: 96, height: 96, fragmentCount: 8, deduction: 1, subsidyHit: 0, image: 'Images/d0948.png', fragmentImage: 'Images/d0948.png', fragmentWidth: 48, fragmentHeight: 48 },
        ateljee: { health: 2, baseSpeed: 1.8, points: 200, width: 48, height: 48, fragmentCount: 6, deduction: 1, subsidyHit: 0, image: 'Images/ateljee48.png', fragmentImage: 'Images/ateljee16.png', fragmentWidth: 32, fragmentHeight: 32 },
        stadskantoor: { health: 2, baseSpeed: 1.5, points: 150, width: 48, height: 48, fragmentCount: 4, deduction: 1, subsidyHit: 0, image: 'Images/stadskantoor.png', fragmentImage: 'Images/stadskantoor.png', fragmentWidth: 32, fragmentHeight: 32 },
        stadgent_minion: { health: 1, baseSpeed: 1.4, points: 100, width: 72, height: 72, fragmentCount: 2, deduction: 0, subsidyHit: 12.5, image: 'Images/stadgent128.png', fragmentImage: 'Images/stadgent128.png', fragmentWidth: 32, fragmentHeight: 32 } // Adjusted size
    };

    // Boss Config (Using your image)
    const BOSS_CONFIG = {
        health: 80,
        points: 5000,
        width: 192, // Image size
        height: 128, // Image size
        attackInterval: 2200,
        moveSpeedX: 2.0,
        image: 'Images/stadgent128.png'
    };

    // --- Game State Variables ---
    let score = 0;
    let afsprakennotasCount = 0;
    let inmengingenCount = 0;
    let meldingenCount = 0;
    let totalCount = 0;
    let subsidiestopCounter = 0;
    let isGameOver = false;
    let isGameRunning = false;
    let isPaused = false;
    let canShoot = true;
    let weaponCooldown = BASE_WEAPON_COOLDOWN;
    let gameSpeed = 'normal'; // Default, loaded from storage
    let soundMuted = false;
    let lastShootTime = 0;
    let activeScreen = 'start';
    let gameLoopId = null;

    // Music specific state
    let currentMusicSelection = 'Audio/8bitarcade.mp3';
    let musicTracks = [];
    let isPreviewingMusic = false;
    let previewTimeoutId = null;
    let isPlayAllActive = false;
    let playAllIndex = 0;

    // Player State
    let shipX = 0;
    let shipY = 0;
    let shipSpeedX = 0;
    let shipSpeedY = 0;
    let moveInput = { x: 0, y: 0 };
    let isMoving = false;
    let isShootingInput = false;
    let activePowerUpType = 'none';
    let nextPowerUpIndex = 0; // <<< For sequential power-ups

    // Timers & Object Arrays
    let virusSpawnTimerId = null;
    let powerUpTimerId = null;
    let bossSpawnTimerId = null;
    let weaponRechargeTimeoutId = null;
    let powerUpEffectTimeoutId = null;
    let activeTimeouts = new Set();
    let viruses = [];
    let lasers = [];
    let powerUps = [];
    let effects = [];
    let bossEnemy = null;

    // Asset paths for preloading
    const IMAGE_ASSETS = [
        'Images/d0948.png', 'Images/ateljee48.png', 'Images/stadskantoor.png',
        'Images/ateljee16.png', 'Images/digi48.png', 'Images/stadgent128.png',
    ];
    const AUDIO_ASSETS = [
        'Audio/laser.mp3', 'Audio/explosion.mp3', 'Audio/alarm.mp3',
        'Audio/bigexplosion.mp3', 'Audio/loser.mp3', 'Audio/powerup.mp3', 'Audio/hit.mp3',
        'Audio/bomba.mp3', 'Audio/doublelaser.mp3',
        'Audio/8bitarcade.mp3', 'Audio/hardcore.mp3', 'Audio/elysium.mp3',
        'Audio/kbounce.mp3', 'Audio/ontheroad.mp3', 'Audio/talkinboutloveanthem.mp3',
        'Audio/vielleichtvielleicht.mp3'
    ];

    // --- Initialization ---
    window.addEventListener('load', initializeGame);

    async function initializeGame() {
        console.log("Initializing Enhanced DigiDefender (Scaled)...");
        populateMusicTracks();
        setupEventListeners();
        loadSettings(); // Load settings *before* setting initial ship/sound state
        setInitialShipPosition();
        updateHUD();
        updateSoundToggleIcon(); // Set initial sound icon based on loaded state

        // Show loading screen and preload assets
        loadingBar.style.width = '10%';
        await preloadAssets();
        loadingBar.style.width = '100%';

        // Hide loading screen
        await new Promise(resolve => setTimeout(resolve, 500)); // Wait for bar animation
        loadingScreen.classList.add('hidden');
        await new Promise(resolve => setTimeout(resolve, 500)); // Wait for fade out

        showScreen('start');
        gameLoop(); // Start animation loop for background effects
        console.log("Initialization Complete.");
    }

    function populateMusicTracks() {
         musicTracks = [];
         const options = backgroundMusicSelect.querySelectorAll('option');
         options.forEach(option => {
             if (option.value && option.value !== 'all') {
                 musicTracks.push(option.value);
             }
         });
     }

    function setupEventListeners() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Buttons
        document.getElementById('start-game').addEventListener('click', startGame);
        document.getElementById('settings').addEventListener('click', () => showScreen('settings'));
        document.getElementById('rules').addEventListener('click', () => showScreen('rules'));
        document.getElementById('leaderboard').addEventListener('click', showLeaderboard);
        document.getElementById('save-settings').addEventListener('click', saveSettings);
        document.getElementById('back-to-menu').addEventListener('click', () => { stopMusicPreview(); showScreen('start'); });
        document.getElementById('back-to-menu-from-rules').addEventListener('click', () => showScreen('start'));
        document.getElementById('restart-game').addEventListener('click', startGame);
        document.getElementById('view-high-scores').addEventListener('click', showLeaderboard);
        document.getElementById('exit-to-menu-from-go').addEventListener('click', exitToMenu);
        document.getElementById('back-from-leaderboard').addEventListener('click', () => showScreen('start'));

        soundToggle.addEventListener('click', toggleSound);

        // Settings Speed Selector
        document.querySelectorAll('.speed-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.speed-option').forEach(opt => opt.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        backgroundMusicSelect.addEventListener('change', handleMusicSelectionChange);
        backgroundMusicPlayer.addEventListener('ended', handleTrackEnd);

        // setupMobileControls(); // <<< REMOVED MOBILE CONTROLS
        window.addEventListener('blur', () => { if (isGameRunning && !isPaused) togglePause(); });
    }

     async function preloadAssets() {
         console.log("Preloading assets...");
         const imagePromises = IMAGE_ASSETS.map(src => new Promise((resolve, reject) => {
             const img = new Image();
             img.onload = resolve;
             img.onerror = () => { console.warn(`Failed to load image: ${src}`); resolve(); };
             img.src = src;
         }));

         const audioPromises = AUDIO_ASSETS.map(src => new Promise((resolve) => {
             const audio = new Audio();
             audio.preload = 'auto';
             audio.src = src;
             audio.load(); // Initiate load
              const canPlayHandler = () => { audio.removeEventListener('canplaythrough', canPlayHandler); audio.removeEventListener('error', errorHandler); resolve(); };
              const errorHandler = () => { console.warn(`Failed to load audio: ${src}`); audio.removeEventListener('canplaythrough', canPlayHandler); audio.removeEventListener('error', errorHandler); resolve(); }; // Resolve on error too
             audio.addEventListener('canplaythrough', canPlayHandler);
             audio.addEventListener('error', errorHandler);
             setTimeout(() => { // Timeout fallback
                  audio.removeEventListener('canplaythrough', canPlayHandler); audio.removeEventListener('error', errorHandler); resolve();
              }, 2000); // 2 sec timeout per audio file
         }));

         try {
             await Promise.all([...imagePromises, ...audioPromises]);
             console.log("Assets preloaded (or load initiated).");
         } catch (error) {
             console.error("Error during asset preloading: ", error);
         }
     }

    function setInitialShipPosition() {
        // Position relative to the logical GAME_WIDTH/HEIGHT
        shipX = (GAME_WIDTH - SHIP_WIDTH) / 2;
        shipY = GAME_HEIGHT * 0.8 - SHIP_HEIGHT / 2;
        spaceship.style.left = `${shipX}px`;
        spaceship.style.top = `${shipY}px`;
        shipSpeedX = 0; shipSpeedY = 0;
        moveInput = { x: 0, y: 0 };
        isMoving = false;
        updatePropellantAnimation();
        // spaceship.style.transform = 'translate(-50%, -50%) rotate(0deg)'; // <<< Updated CSS handles transform differently
        spaceship.style.transform = 'rotate(0deg)'; // Only rotate
    }

    // --- Screen Management ---
    function showScreen(screenId) {
        if (activeScreen === 'settings' && screenId !== 'settings') {
            stopMusicPreview();
        }
        for (const id in screens) {
            if (screens[id]) screens[id].classList.remove('active');
        }
        if (screenId && screens[screenId]) {
            screens[screenId].classList.add('active');
            activeScreen = screenId;
            if (screenId === 'leaderboard') populateLeaderboard();
        } else if (!screenId) {
            activeScreen = 'game'; // Indicate game screen is active
        } else {
            console.error(`Screen ID "${screenId}" not found!`);
        }
    }

    // --- Game States ---
    function startGame() {
        console.log("Starting game...");
        stopMusicPreview();
        showScreen(null);
        resetGame(); // CRITICAL: Reset before starting timers

        isGameRunning = true;
        isGameOver = false;
        isPaused = false;

        // Start timers (Adjust spawn based on speed preference)
        const spawnInterval = MOVEMENT_CONFIG[gameSpeed].baseSpeed > 11 ? 2800 : (MOVEMENT_CONFIG[gameSpeed].baseSpeed < 9 ? 4500 : 3500);
        virusSpawnTimerId = setInterval(spawnVirus, spawnInterval);
        powerUpTimerId = setInterval(spawnPowerUp, POWERUP_SPAWN_INTERVAL);
        bossSpawnTimerId = setInterval(attemptBossSpawn, BOSS_SPAWN_CHECK_INTERVAL);

        playBackgroundMusic();
        if (!gameLoopId) gameLoop();

        // Force repaint/shake to help background anim
        requestAnimationFrame(() => applyScreenShake(1, 10));
    }

    function resetGame() {
        console.log("Resetting game state...");
        // 1. Clear Timers
        clearInterval(virusSpawnTimerId); virusSpawnTimerId = null;
        clearInterval(powerUpTimerId); powerUpTimerId = null;
        clearInterval(bossSpawnTimerId); bossSpawnTimerId = null;
        clearTimeout(weaponRechargeTimeoutId); weaponRechargeTimeoutId = null;
        clearTimeout(powerUpEffectTimeoutId); powerUpEffectTimeoutId = null;
        clearTimeout(previewTimeoutId); previewTimeoutId = null;
        activeTimeouts.forEach(id => clearTimeout(id)); activeTimeouts.clear();

        // 2. Reset Variables
        score = 0; afsprakennotasCount = 0; inmengingenCount = 0; meldingenCount = 0;
        totalCount = 0; subsidiestopCounter = 0;
        isGameOver = false; isGameRunning = false; isPaused = false;
        weaponCooldown = BASE_WEAPON_COOLDOWN; canShoot = true; lastShootTime = 0;
        shipSpeedX = 0; shipSpeedY = 0; moveInput = { x: 0, y: 0 };
        isMoving = false; isShootingInput = false; isPreviewingMusic = false;
        isPlayAllActive = false; playAllIndex = 0; activePowerUpType = 'none';
        nextPowerUpIndex = 0; // <<< Reset power-up sequence

        // 3. Reset HUD & UI
        updateHUD();
        weaponChargeBar.style.transition = 'none';
        weaponChargeBar.style.width = '100%';
        requestAnimationFrame(() => { weaponChargeBar.style.transition = 'width 0.05s linear'; });
        powerUpImage.classList.remove(...POWERUP_TYPES);
        powerUpImage.style.display = 'none';
        if (spaceship) spaceship.style.filter = ''; // Reset ship filter

        // 4. Clear Dynamic DOM Elements & Arrays
        clearLasers(); clearViruses(); clearPowerUps(); clearEffects();
        if (bossEnemy) {
            if(bossEnemy.element) bossEnemy.element.remove();
            if(bossEnemy.healthContainer) bossEnemy.healthContainer.remove();
            bossEnemy = null;
        }

        // 5. Reset Player Position
        setInitialShipPosition();

        // 6. Reset Pause State
        const pauseScreen = document.getElementById('pause-screen');
        if (pauseScreen) pauseScreen.classList.remove('active'); // Hide instead of remove

        // 7. Stop Music
        backgroundMusicPlayer.pause();
        backgroundMusicPlayer.currentTime = 0;
        console.log("Game reset complete.");
    }

    function gameOver() {
        if (isGameOver) return;
        console.log("Game Over!");
        isGameOver = true; isGameRunning = false;

        // Stop timers
        clearInterval(virusSpawnTimerId); virusSpawnTimerId = null;
        clearInterval(powerUpTimerId); powerUpTimerId = null;
        clearInterval(bossSpawnTimerId); bossSpawnTimerId = null;
        clearTimeout(weaponRechargeTimeoutId); weaponRechargeTimeoutId = null;
        clearTimeout(powerUpEffectTimeoutId); powerUpEffectTimeoutId = null;
        clearTimeout(previewTimeoutId); previewTimeoutId = null;
        activeTimeouts.forEach(id => clearTimeout(id)); activeTimeouts.clear();

        finalScoreElement.textContent = score;
        saveHighScore(score);
        fadeOutAudio(backgroundMusicPlayer, 1500);
        isPlayAllActive = false;
        playSound("loser-sound");
        setTimeout(() => showScreen('gameOver'), 500); // Delay showing screen slightly
    }

    function exitToMenu() {
        console.log("Exiting to menu...");
        isGameRunning = false; isPaused = false;
        stopMusicPreview();
        isPlayAllActive = false;
        fadeOutAudio(backgroundMusicPlayer, 500);
        resetGame(); // Full reset
        const pauseScreen = document.getElementById('pause-screen');
        if (pauseScreen) pauseScreen.classList.remove('active');
        showScreen('start');
    }

    // --- Game Loop ---
    function gameLoop(timestamp) {
        gameLoopId = requestAnimationFrame(gameLoop);
        if (isGameRunning && !isPaused) {
            moveSpaceship();
            updateLasers();
            updateViruses();
            updatePowerUps();
            if (bossEnemy) updateBoss();
            updateEffects();
            checkCollisions();
            if (isShootingInput) tryToShoot();
        }
    }

    // --- Player Movement ---
    function handleKeyDown(e) {
         if (isGameOver) return;
        if (isGameRunning && (e.key === 'Escape' || e.key.toLowerCase() === 'p')) {
            togglePause(); return;
        }
        if (!isGameRunning || isPaused) return;

        let inputChanged = false;
        switch (e.key.toLowerCase()) {
            case 'arrowleft': case 'q': case 'a': moveInput.x = -1; inputChanged = true; break;
            case 'arrowright': case 'd': moveInput.x = 1; inputChanged = true; break;
            case 'arrowup': case 'z': case 'w': moveInput.y = -1; inputChanged = true; break;
            case 'arrowdown': case 's': moveInput.y = 1; inputChanged = true; break;
            case ' ':
                 if (!isShootingInput) { isShootingInput = true; tryToShoot(); }
                break;
        }
        if (inputChanged) { isMoving = true; updatePropellantAnimation(); }
    }

    function handleKeyUp(e) {
        if (!isGameRunning || isPaused || isGameOver) return;
         let inputChanged = false;
        switch (e.key.toLowerCase()) {
            case 'arrowleft': case 'q': case 'a': if (moveInput.x < 0) { moveInput.x = 0; inputChanged = true; } break;
            case 'arrowright': case 'd': if (moveInput.x > 0) { moveInput.x = 0; inputChanged = true; } break;
            case 'arrowup': case 'z': case 'w': if (moveInput.y < 0) { moveInput.y = 0; inputChanged = true; } break;
            case 'arrowdown': case 's': if (moveInput.y > 0) { moveInput.y = 0; inputChanged = true; } break;
            case ' ': isShootingInput = false; break;
        }
        // Only update moving state if an actual movement key was released
        if (inputChanged && (e.key.toLowerCase().includes('arrow') || ['q','a','d','z','w','s'].includes(e.key.toLowerCase()))) {
            isMoving = moveInput.x !== 0 || moveInput.y !== 0;
            updatePropellantAnimation();
        }
    }

    function moveSpaceship() {
        const config = MOVEMENT_CONFIG[gameSpeed];
        // Apply acceleration
        if (moveInput.x !== 0) shipSpeedX += moveInput.x * config.acceleration;
        if (moveInput.y !== 0) shipSpeedY += moveInput.y * config.acceleration;
        // Apply friction
        shipSpeedX *= config.friction;
        shipSpeedY *= config.friction;
        // Clamp speed
        shipSpeedX = Math.max(-config.maxSpeed, Math.min(config.maxSpeed, shipSpeedX));
        shipSpeedY = Math.max(-config.maxSpeed, Math.min(config.maxSpeed, shipSpeedY));
        // Stop if slow enough
        if (Math.abs(shipSpeedX) < 0.1) shipSpeedX = 0;
        if (Math.abs(shipSpeedY) < 0.1) shipSpeedY = 0;
        // Update position
        shipX += shipSpeedX;
        shipY += shipSpeedY;
        // Clamp position within logical bounds
        shipX = Math.max(0, Math.min(GAME_WIDTH - SHIP_WIDTH, shipX));
        shipY = Math.max(0, Math.min(GAME_HEIGHT - SHIP_HEIGHT, shipY));
        // Update DOM element position
        spaceship.style.left = `${shipX}px`;
        spaceship.style.top = `${shipY}px`;
        // Apply tilt based on horizontal speed
        const tiltAngle = shipSpeedX * -1.5;
        // spaceship.style.transform = `translate(-50%, -50%) rotate(${tiltAngle}deg)`; // <<< Old CSS
        spaceship.style.transform = `rotate(${tiltAngle}deg)`; // Only apply rotation here
        updatePropellantAnimation(); // Update propellant visual based on speed
    }

    function updatePropellantAnimation() {
        const speedMagnitude = Math.sqrt(shipSpeedX * shipSpeedX + shipSpeedY * shipSpeedY);
        const isActivelyMoving = moveInput.x !== 0 || moveInput.y !== 0 || speedMagnitude > 1; // Consider input OR significant speed
        const isFast = speedMagnitude > MOVEMENT_CONFIG[gameSpeed].maxSpeed * 0.6;

        propellant.classList.toggle('moving', isActivelyMoving);
        propellant.classList.toggle('fast', isFast && isActivelyMoving); // Only fast if actively moving
    }

    // --- Shooting ---
    function tryToShoot() {
        if (!canShoot || isPaused) return;
        const currentTime = Date.now();
        const currentEffectiveCooldown = (activePowerUpType === 'rapid') ? POWERUP_WEAPON_COOLDOWN : BASE_WEAPON_COOLDOWN;

        if (currentTime - lastShootTime >= currentEffectiveCooldown) {
            fireWeapon();
            lastShootTime = currentTime;
            canShoot = false;
            weaponChargeBar.style.width = '0%';
            clearTimeout(weaponRechargeTimeoutId); activeTimeouts.delete(weaponRechargeTimeoutId);
            weaponRechargeTimeoutId = setTimeout(() => {
                 canShoot = true;
                 // Update bar only if not paused (otherwise pause handles it)
                 if (!isPaused) weaponChargeBar.style.width = '100%';
                 activeTimeouts.delete(weaponRechargeTimeoutId);
             }, currentEffectiveCooldown);
            activeTimeouts.add(weaponRechargeTimeoutId);
            animateWeaponRecharge(currentEffectiveCooldown);
        }
    }

    function fireWeapon() {
        switch (activePowerUpType) {
            case 'double': shootDoubleLaser(); break;
            case 'bomb': shootLaserBomb(); break;
            case 'rapid': // Fallthrough intended
            default: shootSingleLaser(); break;
        }
    }

    function shootSingleLaser() {
        const laserX = shipX + SHIP_WIDTH / 2 - LASER_WIDTH / 2;
        const laserY = shipY;
        const laser = document.createElement('div');
        laser.className = 'laser';
        laser.style.left = `${laserX}px`; laser.style.top = `${laserY}px`;
        gameContainer.appendChild(laser);
        lasers.push({ element: laser, x: laserX, y: laserY, type: 'single' });
        playSound('laser-sound');
    }

    function shootDoubleLaser() {
        const laserY = shipY;
        const centerLaserX = shipX + SHIP_WIDTH / 2;
        const laserX1 = centerLaserX - DOUBLE_SHOT_SPACING / 2 - LASER_WIDTH / 2;
        const laserX2 = centerLaserX + DOUBLE_SHOT_SPACING / 2 - LASER_WIDTH / 2;
        const laser1 = document.createElement('div'); laser1.className = 'laser';
        laser1.style.left = `${laserX1}px`; laser1.style.top = `${laserY}px`; gameContainer.appendChild(laser1);
        lasers.push({ element: laser1, x: laserX1, y: laserY, type: 'double' });
        const laser2 = document.createElement('div'); laser2.className = 'laser';
        laser2.style.left = `${laserX2}px`; laser2.style.top = `${laserY}px`; gameContainer.appendChild(laser2);
        lasers.push({ element: laser2, x: laserX2, y: laserY, type: 'double' });
        playSound('double-laser-sound');
    }

    function shootLaserBomb() {
        const bombX = shipX + SHIP_WIDTH / 2 - LASER_BOMB_WIDTH / 2;
        const bombY = shipY;
        const bomb = document.createElement('div'); bomb.className = 'laser-bomb';
        bomb.style.left = `${bombX}px`; bomb.style.top = `${bombY}px`; gameContainer.appendChild(bomb);
        lasers.push({ element: bomb, x: bombX, y: bombY, type: 'bomb', width: LASER_BOMB_WIDTH, height: LASER_BOMB_HEIGHT, speed: LASER_BOMB_SPEED, damage: LASER_BOMB_DAMAGE_MULTIPLIER });
        playSound('laser-bomb-sound');
    }

    function updateLasers() {
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            if (!laser || !laser.element) continue;
            const speed = laser.speed || LASER_SPEED;
            laser.y -= speed; laser.element.style.top = `${laser.y}px`;
            const height = laser.height || LASER_HEIGHT;
            if (laser.y < -height) {
                laser.element.remove(); lasers.splice(i, 1);
            }
        }
    }

    function clearLasers() {
        lasers.forEach(laser => { if (laser.element) laser.element.remove() });
        lasers = [];
    }

    function animateWeaponRecharge(duration) {
        let start = null; let currentRequestId = null;
        function step(timestamp) {
             // Stop if paused
             if (isPaused) { currentRequestId = requestAnimationFrame(step); return; }
             if (!start) start = timestamp;
             const elapsed = timestamp - start;
             const progress = Math.min(elapsed / duration, 1);
             // Only update if the element still exists
             if (weaponChargeBar) {
                 weaponChargeBar.style.width = `${progress * 100}%`;
             }
             if (progress < 1) { currentRequestId = requestAnimationFrame(step); }
             else { currentRequestId = null; }
        }
        // Start animation only if not paused
        if (!isPaused) { currentRequestId = requestAnimationFrame(step); }
    }

    // --- Viruses ---
    function spawnVirus() {
        if (!isGameRunning || isGameOver || isPaused || bossEnemy) return;
        let virusTypeKey; const random = Math.random(); const scoreFactor = Math.min(score / 10000, 1); // Progress factor
        // Weighted random spawn
        if (random < 0.6 - scoreFactor * 0.3) virusTypeKey = 'd0'; // More common early
        else if (random < 0.9 - scoreFactor * 0.1) virusTypeKey = 'ateljee';
        else virusTypeKey = 'stadskantoor'; // Less common early

        const config = VIRUS_CONFIG[virusTypeKey]; if (!config) return;
        const virusElement = document.createElement('div'); virusElement.className = `virus ${virusTypeKey}`;
        const spawnX = Math.random() * (GAME_WIDTH - config.width); const spawnY = -config.height; // Spawn above screen
        virusElement.style.left = `${spawnX}px`; virusElement.style.top = `${spawnY}px`; gameContainer.appendChild(virusElement);
        // Adjust speed based on game setting and score progression
        let speed = config.baseSpeed * (gameSpeed === 'slow' ? 0.8 : (gameSpeed === 'fast' ? 1.3 : 1));
        speed += scoreFactor * 0.8; // Speed increases with score
        viruses.push({
            element: virusElement, x: spawnX, y: spawnY, type: virusTypeKey, config: config,
            health: config.health, speed: speed,
            movementPattern: Math.random() < 0.3 ? 'zigzag' : 'straight', // Add variety
            zigzagOffset: Math.random() * 100, // For zigzag pattern
            isFragment: false, velX: 0, velY: 0, rotation: 0, rotationSpeed: 0, fadeTimer: null
        });
    }

    function updateViruses() {
        const bottomBoundary = GAME_HEIGHT;
        for (let i = viruses.length - 1; i >= 0; i--) {
            if (!viruses[i] || !viruses[i].element) continue; // Skip if already removed
            const virus = viruses[i];
            if (virus.isFragment) {
                // Fragment movement: basic physics + rotation
                virus.x += virus.velX; virus.y += virus.velY; virus.velY += 0.05; // Gravity
                virus.rotation += virus.rotationSpeed;
                virus.element.style.left = `${virus.x}px`; virus.element.style.top = `${virus.y}px`;
                virus.element.style.transform = `rotate(${virus.rotation}deg)`;

                 // Fragment fading logic
                 if (!virus.fadeTimer && virus.element) {
                     // Start fade after a delay
                     virus.fadeTimer = setTimeout(() => {
                         if (virus.element) virus.element.classList.add('fading');
                         // Schedule removal after CSS fade animation completes
                         const removalTimer = setTimeout(() => {
                             if (virus.element) virus.element.remove();
                             // Safe removal from array by finding the object again
                             const index = viruses.findIndex(v => v === virus);
                             if (index > -1) viruses.splice(index, 1);
                             activeTimeouts.delete(removalTimer);
                         }, 800); // Match CSS fade duration (0.8s)
                         activeTimeouts.add(removalTimer);
                          activeTimeouts.delete(virus.fadeTimer); // Clear the fade timer itself
                     }, 2000 + Math.random() * 1000); // Start fading after 2-3 seconds
                     activeTimeouts.add(virus.fadeTimer);
                 }
                 // Immediate removal if fragment goes way off screen
                 if (virus.y > bottomBoundary + 50 || virus.x < -virus.config.width - 50 || virus.x > GAME_WIDTH + 50) {
                    if(virus.fadeTimer) { clearTimeout(virus.fadeTimer); activeTimeouts.delete(virus.fadeTimer); }
                    if (virus.element) virus.element.remove();
                    viruses.splice(i, 1);
                 }

            } else { // Regular virus movement
                virus.y += virus.speed;
                // Zigzag pattern movement
                if (virus.movementPattern === 'zigzag') {
                    const amplitude = 2; const frequency = 0.04;
                    virus.x += Math.sin((virus.y + virus.zigzagOffset) * frequency) * amplitude;
                    // Keep within horizontal bounds
                    virus.x = Math.max(0, Math.min(GAME_WIDTH - virus.config.width, virus.x));
                    virus.element.style.left = `${virus.x}px`;
                }
                virus.element.style.top = `${virus.y}px`;
                // Check if reached bottom
                if (virus.y > bottomBoundary) {
                    handleVirusReachBottom(virus);
                    virus.element.remove(); viruses.splice(i, 1);
                }
            }
        }
    }

    function handleVirusReachBottom(virus) {
        // Fragments reaching bottom cause no penalty
        if (virus.isFragment) return;
        // Apply penalties
        totalCount += virus.config.deduction;
        subsidiestopCounter = Math.min(100, subsidiestopCounter + (virus.config.subsidyHit || 0));
        // Increment specific counters for HUD
        if (virus.type === 'd0') inmengingenCount++;
        else if (virus.type === 'ateljee') afsprakennotasCount++;
        else if (virus.type === 'stadskantoor' || virus.type === 'stadgent_minion') meldingenCount++;

        updateHUD();
        playSound('hit-sound'); // Play a sound for hitting the bottom
        applyScreenShake(5, 150); // Small shake effect
        // Check for game over conditions
        if (totalCount >= MAX_DEDUCTIONS || subsidiestopCounter >= 100) {
             gameOver();
        }
    }

    function damageVirus(virus, index, damageMultiplier = 1) {
        if (!virus) return false; // Safety check
        virus.health -= damageMultiplier;
       

        // Apply visual hit flash effect
        if (virus.element) {
             virus.element.classList.add('hit');
             const hitTimeout = setTimeout(() => {
                 if(virus.element) virus.element.classList.remove('hit');
                 activeTimeouts.delete(hitTimeout);
             }, 100); // Duration of flash
            activeTimeouts.add(hitTimeout);
        }

        // Check if destroyed
        if (virus.health <= 0) {
            score += virus.config.points; // Add score
            createExplosionEffect(virus.x + virus.config.width / 2, virus.y + virus.config.height / 2); // Visual explosion
            playSound('explosion-sound'); // Destruction sound
            // Create fragments if applicable
            if (!virus.isFragment && virus.config.fragmentCount > 0) { createVirusFragments(virus); }
            if (virus.element) virus.element.remove(); // Remove DOM element
            viruses.splice(index, 1); // Remove from active array
            updateHUD();
            return true; // Indicate destroyed
        }
        return false; // Indicate damaged but not destroyed
    }

    function createVirusFragments(parentVirus) {
         const config = parentVirus.config; const count = config.fragmentCount;
         const fragImg = config.fragmentImage || config.image; // Use specific fragment image if available
         const fragW = config.fragmentWidth || config.width / 2;
         const fragH = config.fragmentHeight || config.height / 2;

         for (let i = 0; i < count; i++) {
            const fragmentElement = document.createElement('div');
            fragmentElement.className = `virus-fragment ${parentVirus.type}`; // Style based on parent
            fragmentElement.style.backgroundImage = `url('${fragImg}')`;
            fragmentElement.style.width = `${fragW}px`; fragmentElement.style.height = `${fragH}px`;
            // Spawn near parent's center with some randomness
            const spawnX = parentVirus.x + config.width / 2 - fragW / 2 + (Math.random() - 0.5) * config.width * 0.5;
            const spawnY = parentVirus.y + config.height / 2 - fragH / 2 + (Math.random() - 0.5) * config.height * 0.5;
            fragmentElement.style.left = `${spawnX}px`; fragmentElement.style.top = `${spawnY}px`;
            gameContainer.appendChild(fragmentElement);
            // Initial velocity for explosion effect
            const angle = Math.random() * Math.PI * 2; const speed = 1.5 + Math.random() * 2.5;
            viruses.push({
                element: fragmentElement, x: spawnX, y: spawnY, type: parentVirus.type,
                // Fragments have reduced points/deduction and inherit parent type for image lookup
                config: { width: fragW, height: fragH, points: 50, deduction: 0.5, subsidyHit: 0 },                health: 1, // Fragments usually have 1 health
                speed: 0, // Use velocity instead of constant speed
                isFragment: true,
                velX: Math.cos(angle) * speed, // Horizontal velocity
                velY: Math.sin(angle) * speed - 1, // Vertical velocity (initial upward pop)
                rotation: Math.random() * 360, // Initial rotation
                rotationSpeed: (Math.random() - 0.5) * 8, // Random spin speed/direction
                fadeTimer: null // Timer for fade-out effect
            });
        }
    }

    function clearViruses() {
        viruses.forEach(virus => {
            if(virus.element) virus.element.remove();
            // Clear any pending fade timers for fragments
            if (virus.fadeTimer) { clearTimeout(virus.fadeTimer); activeTimeouts.delete(virus.fadeTimer); }
        });
        viruses = []; // Empty the array
    }

    // --- Power-Ups ---
    function spawnPowerUp() {
         // Conditions to prevent spawning: game stopped, already a powerup, boss active
         if (!isGameRunning || isGameOver || isPaused || powerUps.length > 0 || bossEnemy) return;

        const powerUpSize = 48;
        // Spawn in the upper-middle area of the screen
        const spawnX = Math.random() * (GAME_WIDTH - powerUpSize);
        const spawnY = Math.random() * (GAME_HEIGHT * 0.4) + GAME_HEIGHT * 0.15; // Between 15% and 55% height

        // <<< NEW: Sequential Power-up Logic
        const chosenType = POWERUP_TYPES[nextPowerUpIndex];
        nextPowerUpIndex = (nextPowerUpIndex + 1) % POWERUP_TYPES.length; // Cycle through 0, 1, 2

        powerUpImage.className = ''; // Clear existing type classes first
        powerUpImage.classList.add(chosenType); // Add the specific type class for styling/glow
        powerUpImage.src = 'Images/digi48.png'; // Ensure base image is set (can be same for all)
        powerUpImage.style.left = `${spawnX}px`; powerUpImage.style.top = `${spawnY}px`;
        powerUpImage.style.display = 'block'; // Make it visible
        powerUps.push({
            element: powerUpImage, x: spawnX, y: spawnY,
            width: powerUpSize, height: powerUpSize, type: chosenType
        });
        console.log(`PowerUp Spawned: ${chosenType} (Next index: ${nextPowerUpIndex})`);
    }

    function updatePowerUps() { /* Stationary, no update needed unless they move */ }

    function activatePowerUp(powerUp, index) {
        const collectedType = powerUp.type;
        console.log(`PowerUp Activated: ${collectedType}!`);
        playSound('powerup-sound');
        createPowerUpCollectEffect(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2); // Visual effect
        powerUp.element.style.display = 'none'; // Hide image
        powerUp.element.classList.remove(collectedType); // Remove type class
        powerUps.splice(index, 1); // Remove from active array
        activePowerUpType = collectedType; // Set current power-up state

        // Apply a consistent visual effect (e.g., cyan glow) to ship when *any* powerup is active
        spaceship.style.filter = 'drop-shadow(0 0 15px #4dd0e1)'; // Cyan glow

        // Clear any existing power-up timer and start a new one
        clearTimeout(powerUpEffectTimeoutId); activeTimeouts.delete(powerUpEffectTimeoutId);
        powerUpEffectTimeoutId = setTimeout(() => {
            console.log(`PowerUp Expired: ${activePowerUpType}`);
            activePowerUpType = 'none'; // Reset state
            if (spaceship) spaceship.style.filter = ''; // Remove glow
            activeTimeouts.delete(powerUpEffectTimeoutId);
        }, POWERUP_DURATION);
        activeTimeouts.add(powerUpEffectTimeoutId);
    }

    function clearPowerUps() {
        // Hide the shared power-up image element
        if (powerUpImage) {
             powerUpImage.style.display = 'none';
             powerUpImage.classList.remove(...POWERUP_TYPES); // Remove all type classes
        }
        powerUps = []; // Clear the array

        // Clear the effect timeout and reset state if a power-up was active
         if (powerUpEffectTimeoutId) {
             clearTimeout(powerUpEffectTimeoutId); activeTimeouts.delete(powerUpEffectTimeoutId);
             activePowerUpType = 'none';
             if (spaceship) spaceship.style.filter = ''; // Ensure glow is removed
         }
    }

    // --- Boss ---
    function attemptBossSpawn() {
        // Conditions: Game running, not over, not paused, no boss exists, score threshold met
        if (!isGameRunning || isGameOver || isPaused || bossEnemy || score < BOSS_SPAWN_SCORE_THRESHOLD) return;
        // Chance to spawn
        if (Math.random() < BOSS_SPAWN_CHANCE) {
            spawnBoss();
        }
    }

    function spawnBoss() {
        console.log("Spawning Boss!"); playSound('alarm-sound'); // Alert sound
        const bossElement = document.createElement('img'); bossElement.id = 'boss-image';
        bossElement.src = BOSS_CONFIG.image; bossElement.style.width = `${BOSS_CONFIG.width}px`; bossElement.style.height = `${BOSS_CONFIG.height}px`;
        // Initial position above screen center
        const spawnX = (GAME_WIDTH - BOSS_CONFIG.width) / 2; const spawnY = -BOSS_CONFIG.height - 30;
        bossElement.style.left = `${spawnX}px`; bossElement.style.top = `${spawnY}px`; bossElement.style.display = 'block';

        // Create health bar elements
        const healthContainer = document.createElement('div'); healthContainer.className = 'boss-health-container';
        healthContainer.style.width = `${BOSS_CONFIG.width}px`; healthContainer.style.left = `${spawnX}px`; healthContainer.style.top = `${spawnY - 25}px`; // Position above boss
        const healthBar = document.createElement('div'); healthBar.className = 'boss-health-bar'; healthBar.style.width = '100%'; healthContainer.appendChild(healthBar);

        // Append boss and health bar to game container
        gameContainer.appendChild(bossElement); gameContainer.appendChild(healthContainer);

        // Initialize boss state object
        bossEnemy = {
            element: bossElement, healthContainer: healthContainer, healthBar: healthBar,
            x: spawnX, y: spawnY,
            health: BOSS_CONFIG.health, maxHealth: BOSS_CONFIG.health,
            points: BOSS_CONFIG.points, width: BOSS_CONFIG.width, height: BOSS_CONFIG.height,
            movementPattern: 'entrance', // Initial state
            directionX: 1, // For side-to-side movement
            lastAttackTime: Date.now() + 2000 // Delay first attack slightly
        };
    }

    function updateBoss() {
        if (!bossEnemy) return;
        // Boss Movement Logic
        switch (bossEnemy.movementPattern) {
            case 'entrance': // Move down onto the screen
                bossEnemy.y += 1.5;
                if (bossEnemy.y >= 80) { // Target Y position reached
                    bossEnemy.y = 80;
                    bossEnemy.movementPattern = 'side-to-side'; // Switch pattern
                }
                break;
            case 'side-to-side': // Move left and right
                bossEnemy.x += bossEnemy.directionX * BOSS_CONFIG.moveSpeedX;
                // Reverse direction at edges
                if (bossEnemy.x <= 0 || bossEnemy.x >= GAME_WIDTH - bossEnemy.width) {
                    bossEnemy.directionX *= -1;
                    bossEnemy.x = Math.max(0, Math.min(GAME_WIDTH - bossEnemy.width, bossEnemy.x)); // Clamp position
                }
                break;
        }
        // Update DOM element positions for boss and health bar
        bossEnemy.element.style.left = `${bossEnemy.x}px`; bossEnemy.element.style.top = `${bossEnemy.y}px`;
        bossEnemy.healthContainer.style.left = `${bossEnemy.x}px`; bossEnemy.healthContainer.style.top = `${bossEnemy.y - 25}px`;

        // Boss Attack Logic
        const currentTime = Date.now();
        if (currentTime - bossEnemy.lastAttackTime > BOSS_CONFIG.attackInterval) {
            bossAttack(); // Perform attack
            bossEnemy.lastAttackTime = currentTime; // Reset attack timer
        }

        // Check if boss reached bottom (instant game over)
        if (bossEnemy.y > GAME_HEIGHT) {
             console.log("Boss reached bottom!");
             subsidiestopCounter = 100; // Instant loss condition
             updateHUD();
             createBossExplosionEffect(bossEnemy.x + bossEnemy.width / 2, bossEnemy.y + bossEnemy.height / 2 - 50); // Big explosion
             gameOver();
         }
    }

    function bossAttack() {
         if (!bossEnemy || isPaused) return; // Safety checks
        const spawnCount = Math.floor(Math.random() * 2) + 2; // Spawn 2 or 3 minions
        const minionConfig = VIRUS_CONFIG['stadgent_minion']; if (!minionConfig) return; // Need config

        for (let i = 0; i < spawnCount; i++) {
            const virusElement = document.createElement('div'); virusElement.className = `virus stadgent_minion`; // Use minion class
            // Calculate spawn position relative to boss, spread out slightly
            const angle = (Math.PI / (spawnCount + 1)) * (i + 1); // Distribute angles
            const spawnOffsetX = Math.cos(angle - Math.PI/2) * bossEnemy.width * 0.4; // Offset from center
            const spawnOffsetY = Math.sin(angle - Math.PI/2) * bossEnemy.height * 0.2;
            const spawnX = bossEnemy.x + bossEnemy.width / 2 - minionConfig.width / 2 + spawnOffsetX;
            const spawnY = bossEnemy.y + bossEnemy.height * 0.8 + spawnOffsetY; // Spawn near bottom of boss

            virusElement.style.left = `${spawnX}px`; virusElement.style.top = `${spawnY}px`; gameContainer.appendChild(virusElement);
            // Add minion to the main virus array for updates and collisions
            viruses.push({
                element: virusElement, x: spawnX, y: spawnY, type: 'stadgent_minion',
                config: minionConfig, health: minionConfig.health,
                speed: minionConfig.baseSpeed * (gameSpeed === 'slow' ? 0.8 : (gameSpeed === 'fast' ? 1.3 : 1)), // Adjusted speed
                movementPattern: 'straight', isFragment: false,
                velX: 0, velY: 0, rotation: 0, rotationSpeed: 0, fadeTimer: null
            });
        }
        playSound('laser-sound'); // Or a specific boss attack sound
    }

    function damageBoss(damageMultiplier = 1) {
         if (!bossEnemy) return false; // Not present
         bossEnemy.health -= damageMultiplier;       

         // Update health bar visual
         const healthPercent = Math.max(0, (bossEnemy.health / bossEnemy.maxHealth) * 100);
         bossEnemy.healthBar.style.width = `${healthPercent}%`;

         // Apply hit flash effect
         bossEnemy.element.classList.add('hit');
         const hitTimeout = setTimeout(() => {
             if(bossEnemy && bossEnemy.element) bossEnemy.element.classList.remove('hit');
             activeTimeouts.delete(hitTimeout);
         }, 150); activeTimeouts.add(hitTimeout);

         // Check if defeated
         if (bossEnemy.health <= 0) {
            console.log("Boss Defeated!");
            score += bossEnemy.points; updateHUD(); // Add score
            createBossExplosionEffect(bossEnemy.x + bossEnemy.width / 2, bossEnemy.y + bossEnemy.height / 2); // Big visual
            playSound('bigexplosion-sound'); // Defeat sound
            // Remove boss elements
            if(bossEnemy.element) bossEnemy.element.remove();
            if(bossEnemy.healthContainer) bossEnemy.healthContainer.remove();
            bossEnemy = null; // Clear boss state
            spawnPowerUp(); // Guarantee a power-up drop on defeat
            return true; // Indicate defeated
        }
        return false; // Indicate damaged
    }

    // --- Collision Detection ---
    function checkCollisions() {
        if (isGameOver || isPaused) return;
        // 1. Laser <-> Virus/Boss Collision
        for (let i = lasers.length - 1; i >= 0; i--) {
            if (!lasers[i] || !lasers[i].element) continue; // Skip removed lasers
            const laser = lasers[i]; let laserRemoved = false;
            const laserW = laser.width || LASER_WIDTH; const laserH = laser.height || LASER_HEIGHT;
            const damageMultiplier = laser.damage || 1;

            // Check collision with Boss first
            if (bossEnemy && rectOverlap(laser.x, laser.y, laserW, laserH, bossEnemy.x, bossEnemy.y, bossEnemy.width, bossEnemy.height)) {
                 if (laser.type === 'bomb') { // Special effect for bombs
                     createBombExplosionEffect(laser.x + laserW / 2, laser.y); playSound('bomb-explosion-sound');
                 } else { // Standard laser hit effect
                     createLaserHitEffect(laser.x + laserW / 2, laser.y);
                 }
                 laser.element.remove(); lasers.splice(i, 1); // Remove laser
                 damageBoss(damageMultiplier); // Damage the boss
                 laserRemoved = true; continue; // Move to next laser
            }

            // Check collision with Viruses if laser wasn't removed hitting the boss
            if (!laserRemoved) {
                for (let j = viruses.length - 1; j >= 0; j--) {
                    if (!viruses[j]) continue; // Skip removed viruses
                    const virus = viruses[j];
                    if (rectOverlap(laser.x, laser.y, laserW, laserH, virus.x, virus.y, virus.config.width, virus.config.height)) {
                        if (laser.type === 'bomb') { // Bomb hit effect
                            createBombExplosionEffect(laser.x + laserW / 2, laser.y); playSound('bomb-explosion-sound');
                        } else { // Laser hit effect
                            createLaserHitEffect(laser.x + laserW / 2, laser.y);
                        }
                        laser.element.remove(); lasers.splice(i, 1); // Remove laser
                        damageVirus(virus, j, damageMultiplier); // Damage virus (handles its own removal if needed)
                        laserRemoved = true; break; // Laser hit something, stop checking this laser against other viruses
                    }
                }
            }
        } // End laser loop

        // 2. Ship <-> PowerUp Collision
        for (let i = powerUps.length - 1; i >= 0; i--) {
             if (!powerUps[i]) continue;
            const powerUp = powerUps[i];
            // Use a slightly smaller hitbox for the ship to feel fairer
            if (rectOverlap(shipX + 5, shipY + 5, SHIP_WIDTH - 10, SHIP_HEIGHT - 10, powerUp.x, powerUp.y, powerUp.width, powerUp.height)) {
                activatePowerUp(powerUp, i); // Collect the power-up
                break; // Collect only one power-up per frame
            }
        }

        // 3. Ship <-> Virus/Fragment Collision
        for (let i = viruses.length - 1; i >= 0; i--) {
             if (!viruses[i]) continue;
            const virus = viruses[i];
            // Use a tighter hitbox for the ship collision
             const shipHitboxPadding = 10;
            if (rectOverlap(shipX + shipHitboxPadding, shipY + shipHitboxPadding, SHIP_WIDTH - 2*shipHitboxPadding, SHIP_HEIGHT - 2*shipHitboxPadding, virus.x, virus.y, virus.config.width, virus.config.height)) {
                 // Determine penalty based on whether it's a fragment or full virus
                 const deductionAmount = virus.isFragment ? 0.5 : (virus.config.deduction || 1);
                 const subsidyHitAmount = virus.isFragment ? 0 : (virus.config.subsidyHit || 0);

                totalCount = Math.min(MAX_DEDUCTIONS, totalCount + deductionAmount); // Apply deduction, capped
                subsidiestopCounter = Math.min(100, subsidiestopCounter + subsidyHitAmount); // Apply subsidy hit, capped

                updateHUD(); // Update display
                createShipDamageEffect(); // Visual/audio feedback for ship hit
                playSound('hit-sound'); // Ship specific hit sound?
                playSound('explosion-sound'); // Virus destruction sound

                createExplosionEffect(virus.x + virus.config.width / 2, virus.y + virus.config.height / 2); // Destroy virus visually
                if(virus.element) virus.element.remove(); // Remove virus DOM
                viruses.splice(i, 1); // Remove virus from array

                // Check for game over after taking damage
                if (totalCount >= MAX_DEDUCTIONS || subsidiestopCounter >= 100) {
                     gameOver(); return; // Exit collision check early if game over
                }
                break; // Ship hit one virus/fragment, stop checking for this frame
            }
        } // End ship collision loop
    }


    function rectOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        // Simple AABB collision detection
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    // --- Effects ---
    function createExplosionEffect(x, y) {
        const count = 12; // Number of particles
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div'); particle.className = 'explosion-particle';
            // Start near the center of the explosion
            const initialX = x + (Math.random() - 0.5) * 10; const initialY = y + (Math.random() - 0.5) * 10;
            particle.style.left = `${initialX}px`; particle.style.top = `${initialY}px`;
            particle.style.transform = 'scale(0.1)'; particle.style.opacity = '1'; // Start small and opaque
            // Random direction and force for particle movement
            const angle = Math.random() * Math.PI * 2; const force = 25 + Math.random() * 35;
            const targetX = initialX + Math.cos(angle) * force; const targetY = initialY + Math.sin(angle) * force;
            const duration = 0.35 + Math.random() * 0.35; // Random duration for variety
            // Apply CSS transition for animation
            particle.style.transition = `transform ${duration}s ease-out, opacity ${duration}s ease-out, left ${duration}s ease-out, top ${duration}s ease-out`;
            gameContainer.appendChild(particle); effects.push({ element: particle }); // Add to effects array (for potential future use, maybe not needed now)
            // Trigger the animation in the next frame
            requestAnimationFrame(() => {
                particle.style.transform = 'scale(1.5)'; // Grow particle
                particle.style.opacity = '0'; // Fade out
                particle.style.left = `${targetX}px`; // Move to target position
                particle.style.top = `${targetY}px`;
            });
            // Schedule removal after animation completes
            const cleanupTimer = setTimeout(() => {
                 if (particle.parentNode === gameContainer) particle.remove(); // Remove if still attached
                 const index = effects.findIndex(eff => eff.element === particle); if (index > -1) effects.splice(index, 1);
                 activeTimeouts.delete(cleanupTimer);
            }, duration * 1000 + 50); // Time slightly longer than animation
            activeTimeouts.add(cleanupTimer);
        }
    }

    function createBossExplosionEffect(centerX, centerY) {
         // Create a larger number of particles for a bigger effect
         for (let i = 0; i < 40; i++) {
              // Scatter particles around the boss's center
              createExplosionEffect(centerX + (Math.random() - 0.5) * BOSS_CONFIG.width * 0.8, centerY + (Math.random() - 0.5) * BOSS_CONFIG.height * 0.8);
         }
         applyScreenShake(18, 600); // Stronger, longer screen shake for boss defeat
    }

    function createShipDamageEffect() {
        // Determine the base filter (if a power-up is active)
         const baseFilter = activePowerUpType !== 'none' ? 'drop-shadow(0 0 15px #4dd0e1)' : '';
         // Apply a generic bright flash filter temporarily
         const damageFilter = 'brightness(1.8) contrast(1.5) saturate(2)';
         if (spaceship) {
             spaceship.style.filter = `${baseFilter} ${damageFilter}`; // Combine filters
             // Set a timeout to remove the damage filter
             const filterTimeout = setTimeout(() => {
                 if (spaceship) spaceship.style.filter = baseFilter; // Restore original filter
                 activeTimeouts.delete(filterTimeout);
             }, 120); // Duration of the flash effect
             activeTimeouts.add(filterTimeout);
         }
         applyScreenShake(10, 250); // Moderate screen shake on taking damage
    }

    function applyScreenShake(intensity, duration) {
         // Don't shake if paused or game over
         if (isPaused || isGameOver) return;
         const startTime = Date.now(); let shakeId = null;
         function shakeStep() {
             const elapsed = Date.now() - startTime;
             // Stop shaking if duration is over or game paused/over
             if (elapsed >= duration || isPaused || isGameOver) {
                 if(gameContainer) gameContainer.style.transform = 'translate(0, 0)'; // Reset position
                 if (shakeId) cancelAnimationFrame(shakeId); // Stop animation loop
                 shakeId = null; return;
             }
             // Calculate shake amount, reducing over time
             const progress = 1 - (elapsed / duration);
             const x = (Math.random() - 0.5) * 2 * intensity * progress;
             const y = (Math.random() - 0.5) * 2 * intensity * progress;
             // Apply transform if container exists
             if(gameContainer) gameContainer.style.transform = `translate(${x}px, ${y}px)`;
             // Continue the animation
             shakeId = requestAnimationFrame(shakeStep);
         }
         // Start the animation
         shakeId = requestAnimationFrame(shakeStep);
    }

     function createLaserHitEffect(x, y) {
         const flash = document.createElement('div'); flash.className = 'laser-hit-flash';
         // Position centered on the hit location
         flash.style.left = `${x - 17.5}px`; flash.style.top = `${y - 17.5}px`;
         gameContainer.appendChild(flash); effects.push({ element: flash });
         // Schedule removal based on CSS animation duration
         const cleanupTimer = setTimeout(() => {
              if (flash.parentNode === gameContainer) flash.remove();
              const index = effects.findIndex(eff => eff.element === flash); if (index > -1) effects.splice(index, 1);
              activeTimeouts.delete(cleanupTimer);
         }, 200); // Match CSS @keyframes flashFadeCyan duration
         activeTimeouts.add(cleanupTimer);
     }

    function createBombExplosionEffect(x, y) {
         const flash = document.createElement('div'); flash.className = 'bomb-explosion-flash';
         // Position centered on the hit location
         flash.style.left = `${x - 35}px`; flash.style.top = `${y - 35}px`;
         gameContainer.appendChild(flash); effects.push({ element: flash });
         // Schedule removal based on CSS animation duration
         const cleanupTimer = setTimeout(() => {
             if (flash.parentNode === gameContainer) flash.remove();
             const index = effects.findIndex(eff => eff.element === flash); if (index > -1) effects.splice(index, 1);
             activeTimeouts.delete(cleanupTimer);
         }, 300); // Match CSS @keyframes flashFadeLargeCyan duration
         activeTimeouts.add(cleanupTimer);
         createExplosionEffect(x, y); // Add standard particles as well for texture
    }

     function createPowerUpCollectEffect(x, y) {
         const ring = document.createElement('div'); ring.className = 'powerup-collect-effect';
         // Position centered on the power-up location
         ring.style.left = `${x - 25}px`; ring.style.top = `${y - 25}px`;
         gameContainer.appendChild(ring); effects.push({ element: ring });
         // Schedule removal based on CSS animation duration
         const cleanupTimer = setTimeout(() => {
             if (ring.parentNode === gameContainer) ring.remove();
             const index = effects.findIndex(eff => eff.element === ring); if (index > -1) effects.splice(index, 1);
             activeTimeouts.delete(cleanupTimer);
         }, 500); // Match CSS @keyframes collectZoomCyan duration
         activeTimeouts.add(cleanupTimer);
     }

     function updateEffects() { /* Primarily driven by CSS animations and timed removals */ }
     function clearEffects() {
         // Remove any effect elements still in the DOM
         effects.forEach(effect => { if(effect.element?.parentNode === gameContainer) effect.element.remove(); });
         effects = []; // Clear the tracking array
     }

    // --- Utilities ---
    function updateHUD() {
        // Update text content of HUD elements, formatting numbers as needed
        if (hudScore) hudScore.textContent = `Score: ${score}`;
        if (afsprakennotasElement) afsprakennotasElement.textContent = afsprakennotasCount;
        if (inmengingenElement) inmengingenElement.textContent = inmengingenCount;
        if (meldingenElement) meldingenElement.textContent = meldingenCount;
        // Display total count, showing .5 if necessary
        if (totalCounterElement) totalCounterElement.textContent = `${totalCount % 1 === 0 ? totalCount : totalCount.toFixed(1)}/${MAX_DEDUCTIONS}`;
        if (subsidiestopElement) subsidiestopElement.textContent = `${subsidiestopCounter}%`;
    }

    function playSound(soundId) {
        if (soundMuted || !soundId || soundId === 'no sound necessary') return; // Ignore if muted or no ID
        const sound = document.getElementById(soundId);
        if (sound) {
            // Allow short sounds to overlap slightly, reset longer ones or if paused
            const shortSounds = ['laser-sound', 'double-laser-sound', 'hit-sound', 'laser-bomb-sound'];
            if (!shortSounds.includes(soundId) || sound.paused) {
                 sound.currentTime = 0; // Reset playback position
            }
            // Optional: Adjust volume per sound type
            if (soundId === 'double-laser-sound' || soundId === 'laser-bomb-sound') {
    volume = 0.3; // Very quiet for these specific sounds
} else if (soundId === 'laser-sound') {
    volume = 0.5; // Volume for generic laser sounds
} else if (soundId === 'hit-sound') {
    volume = 0.5;
} else if (soundId === 'explosion-sound') {
    volume = 0.3;
} else if (soundId === 'alarm-sound') {
    volume = 0.45;
} else if (soundId === 'powerup-sound') {
    volume = 0.55;
} else if (soundId === 'loser-sound') {
    volume = 0.7;
}
            sound.volume = volume;

            // Play the sound, catch errors (e.g., user hasn't interacted yet)
            sound.play().catch(e => {/* console.warn(`Sound play failed for ${soundId}:`, e) */});
        } else {
            console.warn(`Sound element not found: ${soundId}`);
        }
    }

    // --- Music Specific Functions ---
    function handleMusicSelectionChange(event) {
        const selectedValue = event.target.value;
        stopMusicPreview(); isPlayAllActive = false; backgroundMusicPlayer.loop = false;
        currentMusicSelection = selectedValue;
        // If a specific track is chosen, start preview
        if (selectedValue && selectedValue !== 'all') {
            isPreviewingMusic = true; backgroundMusicPlayer.src = selectedValue;
            if (!soundMuted) { backgroundMusicPlayer.play().catch(e => console.warn("Preview play failed:", e)); }
            // Set timeout to stop preview
            previewTimeoutId = setTimeout(stopMusicPreview, MUSIC_PREVIEW_DURATION);
            activeTimeouts.add(previewTimeoutId);
        } else { // 'All' or invalid selected, stop music
            backgroundMusicPlayer.pause(); backgroundMusicPlayer.currentTime = 0;
        }
    }

    function stopMusicPreview() {
         if (isPreviewingMusic) {
             clearTimeout(previewTimeoutId); activeTimeouts.delete(previewTimeoutId);
             previewTimeoutId = null; isPreviewingMusic = false;
             // Only stop playback if 'Play All' isn't active (it shouldn't be during preview)
             if (!isPlayAllActive) {
                 backgroundMusicPlayer.pause(); backgroundMusicPlayer.currentTime = 0;
             }
         }
     }

    function handleTrackEnd() {
        // If 'Play All' is active and game is running, play the next track
        if (isPlayAllActive && !isPaused && isGameRunning && !isGameOver && musicTracks.length > 0) {
              playAllIndex = (playAllIndex + 1) % musicTracks.length; // Cycle index
              backgroundMusicPlayer.src = musicTracks[playAllIndex];
              console.log(`Playing next track (${playAllIndex + 1}/${musicTracks.length}): ${musicTracks[playAllIndex]}`);
              if (!soundMuted) {
                  // Short delay might help avoid race conditions
                  setTimeout(() => { if (isPlayAllActive && !soundMuted) backgroundMusicPlayer.play().catch(e => console.warn("Play All next track failed:", e)); }, 100);
              }
          } else if (backgroundMusicPlayer.loop) {
             // Standard loop handled by the audio element itself
          }
     }

    function playBackgroundMusic() {
        if (soundMuted || isPreviewingMusic) return; // Don't play if muted or previewing
        backgroundMusicPlayer.volume = 0.6; // Set volume

        if (currentMusicSelection === 'all') {
            isPlayAllActive = true; backgroundMusicPlayer.loop = false; // Disable loop for 'Play All'
            if (musicTracks.length > 0) {
                 playAllIndex = playAllIndex % musicTracks.length; // Ensure index is valid
                 const nextTrack = musicTracks[playAllIndex];
                 // Play only if paused or src is different
                 if (backgroundMusicPlayer.currentSrc.split('/').pop() !== nextTrack.split('/').pop() || backgroundMusicPlayer.paused) {
                     backgroundMusicPlayer.src = nextTrack;
                     console.log(`Starting/Resuming 'Play All' with: ${nextTrack}`);
                     backgroundMusicPlayer.play().catch(e => console.warn("Play All start/resume failed:", e));
                 }
            } else { console.warn("Play All selected, but no tracks found!"); }
        } else { // Specific track selected
            isPlayAllActive = false; backgroundMusicPlayer.loop = true; // Enable loop for single tracks
            const intendedSrc = currentMusicSelection;
            // Play only if paused or src is different
            if (backgroundMusicPlayer.currentSrc.split('/').pop() !== intendedSrc.split('/').pop() || backgroundMusicPlayer.paused) {
                 backgroundMusicPlayer.src = intendedSrc;
                 console.log(`Playing/Resuming single track: ${intendedSrc}`);
                 backgroundMusicPlayer.play().catch(e => console.warn("Single track play/resume failed:", e));
             }
        }
    }

    function fadeOutAudio(audioElement, duration) {
         // Check conditions where fade is not needed or possible
         if (!audioElement || audioElement.paused || soundMuted || !audioElement.src || audioElement.volume === 0) {
             if (audioElement) audioElement.pause(); return Promise.resolve();
         }
         return new Promise((resolve) => {
             const startVolume = audioElement.volume; const fadeStartTime = performance.now();
             let fadeAnimFrame;
             function fadeStep(now) {
                 const elapsed = now - fadeStartTime; const progress = Math.min(elapsed / duration, 1);
                 let newVolume = startVolume * (1 - progress);
                 // Stop fade if volume is negligible, muted, or element lost src
                 if (newVolume <= 0.01 || soundMuted || !audioElement.src) {
                     newVolume = 0; audioElement.volume = newVolume; audioElement.pause();
                     if (fadeAnimFrame) cancelAnimationFrame(fadeAnimFrame); resolve();
                 } else {
                     audioElement.volume = newVolume; fadeAnimFrame = requestAnimationFrame(fadeStep);
                 }
             }
             fadeAnimFrame = requestAnimationFrame(fadeStep);
         });
     }

    function toggleSound() {
        soundMuted = !soundMuted;
        updateSoundToggleIcon(); // Update visual state immediately
        console.log("Sound Muted:", soundMuted);
        // Mute/unmute ALL audio elements on the page
        const gameAudios = document.querySelectorAll('audio');
        gameAudios.forEach(audio => { if (audio) audio.muted = soundMuted; });

        if (soundMuted) {
            // Pause music and stop any preview
            backgroundMusicPlayer.pause();
            stopMusicPreview();
        } else {
            // Resume music *only* if the game is actually running or paused
            // (don't auto-start on menu screens unless a preview was active)
            if (!isPreviewingMusic && (isGameRunning || isPaused)) {
                playBackgroundMusic();
            } else if (isPreviewingMusic) { // Resume preview if it was interrupted by muting
                 backgroundMusicPlayer.play().catch(e => console.warn("Resume preview on unmute failed:", e));
            }
        }
        // Save the muted state to localStorage
        localStorage.setItem('digiDefenderSoundMuted', soundMuted);
    }

    function updateSoundToggleIcon() {
        if (soundToggle) {
            soundToggle.classList.toggle('on', !soundMuted); // 'on' class if NOT muted
            soundToggle.classList.toggle('off', soundMuted); // 'off' class if muted
        }
    }

    function loadSettings() {
        // Load game speed setting
        gameSpeed = localStorage.getItem('digiDefenderGameSpeed') || 'normal';
        document.querySelectorAll('.speed-option').forEach(opt => opt.classList.toggle('selected', opt.dataset.speed === gameSpeed));
        // Load music selection
        currentMusicSelection = localStorage.getItem('digiDefenderBackgroundMusic') || 'Audio/8bitarcade.mp3';
        if (backgroundMusicSelect) backgroundMusicSelect.value = currentMusicSelection;
        isPlayAllActive = (currentMusicSelection === 'all');
        // Load sound muted state
        const savedMuteState = localStorage.getItem('digiDefenderSoundMuted');
        soundMuted = savedMuteState === 'true'; // Set internal state (visual update happens after)
    }

    function saveSettings() {
        stopMusicPreview(); // Stop any active music preview
        // Save selected game speed
        const selectedSpeedElement = document.querySelector('.speed-option.selected');
        if (selectedSpeedElement) { gameSpeed = selectedSpeedElement.dataset.speed; localStorage.setItem('digiDefenderGameSpeed', gameSpeed); }
        // Save selected music
        if (backgroundMusicSelect) {
            currentMusicSelection = backgroundMusicSelect.value; localStorage.setItem('digiDefenderBackgroundMusic', currentMusicSelection);
            isPlayAllActive = (currentMusicSelection === 'all');
            // Stop current music and potentially start new one if game running
            backgroundMusicPlayer.pause(); backgroundMusicPlayer.currentTime = 0;
            if (!soundMuted && isGameRunning && !isPaused) { playBackgroundMusic(); }
        }
        // Sound state is saved instantly in toggleSound, no need to save here
        showScreen('start'); // Go back to the start screen
    }

    // --- MOBILE CONTROLS SETUP FUNCTION REMOVED ---

    // --- Pause ---
    function togglePause() {
        if (!isGameRunning || isGameOver) return; // Can't pause if not running or over
        isPaused = !isPaused; console.log("Game Paused:", isPaused);
        let pauseScreen = document.getElementById('pause-screen');

        if (isPaused) {
             fadeOutAudio(backgroundMusicPlayer, 300); // Gently pause music
             gameContainer.style.transform = 'translate(0, 0)'; // Stop any active screen shake

            // Create pause screen dynamically if it doesn't exist
            if (!pauseScreen) {
                pauseScreen = document.createElement('div');
                pauseScreen.id = 'pause-screen';
                pauseScreen.className = 'screen'; // Reuse base screen styles
                pauseScreen.innerHTML = `
                    <h2>PAUZE</h2>
                    <p>Druk op ESC of P om te hervatten</p>
                    <div>
                        <button id="resume-game-btn">Hervat Spel</button>
                        <button id="exit-to-menu-btn">Terug Naar Menu</button>
                    </div>`;
                gameContainer.appendChild(pauseScreen);
                 // Attach listeners only once when creating
                 document.getElementById('resume-game-btn').addEventListener('click', togglePause);
                 document.getElementById('exit-to-menu-btn').addEventListener('click', exitToMenu);
            }
            pauseScreen.classList.add('active'); // Show the pause screen overlay
        } else { // Resuming
             if (!soundMuted) playBackgroundMusic(); // Resume music playback
             if (pauseScreen) pauseScreen.classList.remove('active'); // Hide the pause screen

              // Resume weapon recharge visual/timer accurately
              if (!canShoot && weaponRechargeTimeoutId) {
                  const timeSinceShot = Date.now() - lastShootTime;
                  const currentEffectiveCooldown = (activePowerUpType === 'rapid') ? POWERUP_WEAPON_COOLDOWN : BASE_WEAPON_COOLDOWN;
                  const timeRemaining = Math.max(0, currentEffectiveCooldown - timeSinceShot);

                  if (timeRemaining > 0) {
                       // Update bar visually to correct progress
                       const progress = Math.max(0, timeSinceShot / currentEffectiveCooldown);
                       weaponChargeBar.style.width = `${progress * 100}%`;
                       // Restart the animation for the remaining time
                       animateWeaponRecharge(timeRemaining);
                       // Clear old timeout and set new one for remaining duration
                       clearTimeout(weaponRechargeTimeoutId); activeTimeouts.delete(weaponRechargeTimeoutId);
                       weaponRechargeTimeoutId = setTimeout(() => { canShoot = true; if (!isPaused) weaponChargeBar.style.width = '100%'; activeTimeouts.delete(weaponRechargeTimeoutId); }, timeRemaining);
                       activeTimeouts.add(weaponRechargeTimeoutId);
                  } else { // Cooldown already finished while paused
                       canShoot = true; weaponChargeBar.style.width = '100%';
                       clearTimeout(weaponRechargeTimeoutId); activeTimeouts.delete(weaponRechargeTimeoutId);
                  }
              } else if (canShoot) { // If weapon was ready, ensure bar is full
                  weaponChargeBar.style.width = '100%';
              }
        }
    }

    // --- Leaderboard ---
    function saveHighScore(finalScore) {
        try {
            // Use a distinct key for this version's scores
            const highScores = JSON.parse(localStorage.getItem('digiDefenderHighScores_v2.1') || '[]');
            const currentDate = new Date().toLocaleDateString('nl-BE', { day: '2-digit', month: '2-digit', year: 'numeric' }); // Format DD/MM/YYYY
            highScores.push({ score: finalScore, date: currentDate });
            // Sort descending by score
            highScores.sort((a, b) => b.score - a.score);
            // Keep only the top 10 scores
            const topScores = highScores.slice(0, 10);
            localStorage.setItem('digiDefenderHighScores_v2.1', JSON.stringify(topScores));
            console.log("High score saved:", topScores);
            return topScores; // Return the updated list (optional)
        } catch (error) { console.error("Failed to save high score:", error); return []; }
    }

    function showLeaderboard() { populateLeaderboard(); showScreen('leaderboard'); }

    function populateLeaderboard() {
        const leaderboardContent = document.querySelector('#leaderboard-screen .leaderboard-content'); if (!leaderboardContent) return;
        try {
            const highScores = JSON.parse(localStorage.getItem('digiDefenderHighScores_v2.1') || '[]');
            let tableHTML = '';
            if (highScores.length === 0) {
                tableHTML = `<p class="no-scores">Nog geen high scores!</p>`;
            } else {
                // Create table structure
                tableHTML = `<table><thead><tr><th>#</th><th>Score</th><th>Datum</th></tr></thead><tbody>`;
                // Add rows for each score
                highScores.forEach((entry, index) => {
                     // Sanitize data before displaying
                     const safeScore = Number(entry.score) || 0;
                     const safeDate = String(entry.date || 'N/A').replace(/</g, "&lt;"); // Prevent basic XSS
                    tableHTML += `<tr><td>${index + 1}</td><td>${safeScore}</td><td>${safeDate}</td></tr>`;
                });
                tableHTML += `</tbody></table>`;
            }
            leaderboardContent.innerHTML = tableHTML; // Update the content area
        } catch (error) { console.error("Failed to load high scores:", error); leaderboardContent.innerHTML = `<p class="no-scores">Fout bij laden scores.</p>`; }
    }

</script>
</body>
</html>
